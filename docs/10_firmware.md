# Firmware

This section describes the **connection between the software and the hardware** of the Gretchen robot. The embedded microcontroller on the Sensorimotor board is an important and complex hardware component, which is worth discussing in detail before moving on to the firmware installation and the communication between the boards and the computer.

## ATmega238P

Each servo motor powering the Gretchen robot contains a Sensorimotor board with an **embedded ATmega238P**, which is a high-performance and open-source single-chip microcontroller created by Atmel and commonly used for open-source projects e.g. Arduino UNO. Its **maximum operating frequency amounts 20 MHz** and it operates on a **voltage ranging from 3.3V to 5.5V**. The ATmega238P has several important features, which are relevant to examine in the context of the software of the Gretchen robot, namely: **fuses, In-System Programmable Flash, Pulse Width Modulation channels,
Serial Communication** and **Serial-Peripheral-Interface**. We elaborate on each of these features in the following subsections.

The **fuses** are 3 bytes, called **low, high and extended byte**, which store the configuration of the ATmega238P, each bit corresponding to a setting or flag. For all fuses, a value of 1 means not set and a value of 0(zero) means set. The **low byte fuse** manages the clock settings and speed, as well as the delay after the startup of the microcontroller. The **high fuse** determines the settings of serial programming and preserving or erasing EEPROM and the bootloader size. The **extended fuse** ensures that the microcontroller receives enough voltage in order to work properly and it is not set by default. The default fuse settings of the low, high and extended fuses of the ATmega238P are 0x62 (B01100010), 0xD9 (B11011001) and 0xFF (B11111111) respectively.

## Firmware 

The **firmware** is the essential software program or set of instructions running on a microcontroller, which ensures communication with other devices and determines its actions. It is commonly located either in the Electrically Erasable Programmable Read-Only Memory (EEPROM) or in the Flash Memory. Both of them belong to the non-volatile type of memory, meaning that the stored data remains unchanged even after disconnecting the power supply. The main difference between EEPROM and flash memory is that flash memory is block-accessible, meaning that an entire block must be erased before writing, while EEPROM erases one byte at a time. Flash memory is therefore faster and cheaper, however it wears out faster than EEPROM due to a smaller number of write cycles. The EEPROM memory of the ATmega328P microcontroller is 1.024KB and can be rewritten up to 100,000 times, while its flash memory is 32KB and can be rewritten up to 10,000 times. Due to the fact that the firmware is commonly uploaded on the flash memory, this process is often called "flashing the firmware".

## In-System Programming

**In-System Programming (ISP)** allows programming microcontrollers or other embedded devices, without removing them from the board. The **Serial-Peripheral-Interface (SPI)** provides the communication between the microcontroller and the computer and it consists of **3 wires**: **Serial Clock (SCK)**, **Master In – Slave Out (MISO)**, and **Master Out – Slave In (MOSI)**. The clock line synchronizes the communication between the computer (master) and the target system (slave), so that at each pulse of the clock line, the microcontroller receives one bit through the MOSI line and simultaneously sends one bit to the computer through the MISO line. The **ISP header has 3 additional pins** besides the ones of the SPI, namely: **Reset**, **Power (5V)** and **Ground (GND)**. The Reset line is controlled by the master and ensures that once the communication has started it’s not interrupted. For transferring the desired
firmware to the microcontroller, we used an [AVR-ISP MySmartUSB Light Programmer](https://shop.myavr.com/index.php?sp=article.sp.php&artID=200006), which is illustrated in the upper part of figure below. Due to the 5V and the GND pins **an external power supply is not necessary**, as the programmer draws enough power from the computer for supplying the microcontroller with sufficient voltage to ensure its proper functionality.

## Firmware Tests

The assembly process of the actuators involves several steps which require precision and very careful actions, in order to avoid accidental damage of the boards. For instance, the soldering process of the capacitor involved heating the board for a longer time, as the ground pin was sinking a lot of heat into the board. Moreover, the board LEDs are located very close to the capacitor pins and can be easily damaged by the soldering iron if it slips a few millimeters away. Furthermore, the 3D-printed motor lid can damage the insulation of the motor cables, if the temperature sensor is slightly shifted, potentially causing unexpected behaviors of the board or short circuits. Thus, **it is essential to test the boards’ functionality before uploading the firmware and connecting it to the serial bus**. The blinky test script, which can be found in the [Sensorimotor repository](https://github.com/suprememachines/sensorimotor/tree/3a87a29950bdd637be39ed34af577aef0984a3cb), provides the possibility to **check if the board electronics are intact**, if the on-board microcontroller can be connected to the computer and respond to basic requests, if its LEDs are intact and if the serial bus and ISP work. The advantage of using a test script as blinky is that no other tools are required to test if the hardware works properly. Additionally, blinky **changes the default values of the fuses**. The default value of the low byte fuse of the Atmega328p is changed from 0x62 to 0xCF, meaning that the clock speed will be bigger than 8MHz (instead of dividing it by 8), there will be no clock output and the chip will startup with a small delay. The high byte remains unchanged at 0xD9, meaning that serial programming is allowed, the EEPROM memory is preserved and the bootloader has a maximum size of 4KB. The extended fuse is changed to 0xFD, which signifies that the minimal voltage limit is 2,7V. We uploaded the blinky test script to the ATmega238P via the [AVR Programmer](https://shop.myavr.com/index.php?sp=article.sp.php&artID=200006). The programmer supplies the board with 5V, which is **enough for successfully transferring the code to the chip**, but **not enough for powering the on-board LEDs**. In order to check if the test ran successfully and the LEDs were blinking, we had to plug in one RS485 connector with the battery, as shown on the bottom part of figure below. After this step, the firmware can be safely flashed on the microcontroller.

<figure>
  <img src="../img_gretchen/firmware.png"/>
  <figcaption>
The communication channels between the servos with embedded Sensorimotor
boards and the computer: On the top part - the USB to ISP Programmer is shown, which is
used for the process of flashing the firmware. The bottom part illustrates the communication
between the computer and the robot’s serial bus via a USB to Serial Bridge and a power
supply attached to it.
</figcaption>
</figure>

## RS-485 Bus

The motors are connected with each other in a **daisy-chained manner** and communicate with each other and **the external computer via the RS-485 serial bus**. RS-485 is a data transmission standard for serial communication, which allows for robust transmission of moderate data rates over long distances. It consists of **4 lines**: **power (VCC), ground (GND), data lines A and B**. The RS485 network uses **differential communication of two data lines**, meaning that the **voltage of the data line A is the inverse of the one on the line B**. In other words, the same signal is passed through both lines, however, on one line it is inverted, thereby making the bus **immune against noise**. The output of the receiver is 1 if the voltage of data line A is 200mV bigger than the one of B, and 0 - otherwise. The RS-485 bus lets up to 32 devices to communicate via **a single pair of wires**, allowing only one device to communicate with the other ones via the bus at a
time, with a **data rate of 100Hz (10ms) per cycle**. There are multiple options of connecting the external computer to the serial bus of the robot, by using a USB-to-Serial/RS485 device, such as FTDI USB-RS485-PCB, Digitus DA-70157 or In-Circuit USB-RS485-Bridge. We used the **In-Circuit USB-RS485-Bridge** by connecting it to the robot’s foot. As opposed to the other USB-to-Serial devices mentioned above, the USB-RS485-Bridge has only the **3 IO pins** which are needed to connect to the robot’s bus: **RS485-A, RS485-B** and **Ground**. We have soldered the ground cables of the USB-RS485-Bridge and of a battery, and created a USB-to-Serial connector which is illustrated on the lower part of the figure above.

## Pulse Width Modulation

The actuators of the Gretchen robot are controlled by **Pulse Width Modulation (PWM)**, which is a commonly used control approach of **powering brushed DC motors of legged robots and robotic arms**. PWM is a technique of digitally encoding analog signals by chopping an electrical signal in discrete parts. The voltage and the current are controlled by **turning the power on and off at a fast rate**. The period of time in which the power is turned on - is called a **duty cycle**. For instance, if the power is on 20% and off - 80% of the time, the PWM output is at a 20% duty cycle. The advantage of the PWM is that it **eliminates the need for a digital-to-analog conversion**. Due to the fact that the **signal remains digital** all the way from the processor to the controlled system, **the noise effects are minimized**, as the noise has to be strong enough to change a logical 1 to 0, or the other way around. The maximally allowed PWM duty cycle is used for setting the voltage limit with which the actuators of the Gretchen robot are powered. 

