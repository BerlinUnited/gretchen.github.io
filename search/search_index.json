{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction An overview of the assembly stages and of the major hardware components. Welcome Research on embodied artificial intelligence (Embodied AI) based on biological systems is becoming increasingly significant. Biological systems are inherently decentralized, with individual parts of the body having their own intelligence. Intelligent behavior only arises from the interaction of individual components and their interaction with the environment. Hence, the body is an indispensable part of any research of intelligence. Humanoid robots are particularly interesting, however they are still difficult to access, are associated with high costs and often have to be developed by scientists themselves, therby restricting the group of users. In this project we are developing a humanoid robot \u201cGretchen\u201d for research and teaching. Our focus lies on the openness of hardware and software, as well as on the accessibility of the robot for non-specialist researchers. A prototype of the Gretchen robot is already being used in seminars at the Adaptive Systems Group at Humboldt University. The Gretchen robot is a versatile platform for training, as its modular structure enables work and experimentation through hardware design, actuators, 3D printed components, firmware, power supply, communication bus, software libraries or the API. This documentation gives an overview over the current state of the hardware and the software base of the Gretchen robot , as well as brings together all further contributions from various projects and seminars. The Gretchen Robot The Gretchen robot was designed and developed by Matthias Kubisch in collaboration with the AI Brain Company in 2018. One of the prototypes of the robot is currently used for academic research and education in the lab of the Adaptive Systems Group in the Computer Science department of the Humboldt University. The Gretchen robot is a versatile platform for education, as its modular design allows working and experimenting by its hardware design, actuators, 3D-printed components, firmware, power supply, communication bus, software libraries or the API. Matthias Kubisch and Gretchen The Gretchen robot is 74 cm high, weighs approximately 5 kg, and has 10 degrees of freedom (DoFs), 5 of which are in each leg: 2 in the hip (roll and pitch), 1 in the knee (pitch), and 2 in the ankle (roll and pitch). The robot resembles the lower part of the human body, by incorporating feet, legs and lower torso as shown in the picture below. Matthias Kubisch and the Gretchen robot The body parts are made from low-cost materials such as wood and 3D-printed components, the CAD files of which can be found on GitHub https://github.com/suprememachines . The robot cannot be purchased, however, it can be manufactured from 3D-printed as well as commercially available materials and electronic components. The Sensorimotor boards are the only components that require custom manufacturing and they can be ordered by using the provided schematic circuits. Gretchen\u2019s overall manufacturing costs lie at roughly 1,400AC. Team The research group NaoTH is part of the research lab for Adaptive Systems at Humboldt-Universit\u00e4t zu Berlin headed by Prof. Verena Hafner. At the current state the core team consists of about 12 students of Bachelor, Master/Diploma, and PhD levels. Besides the direct participation at the RoboCup competitions NaoTH is involved in teaching at the university, public engagement and building of the RoboCup community. The NaoTH Team at Rohow, where the Gretchen robot was introduced to the RoboCup community for the first time. NaoTH was founded at the end of 2007 at the AI research lab headed by Prof. Hans-Dieter Burkhard. As a direct successor of the Aibo Team Humboldt which was active in the Four Legged League of the RoboCup as a part of the GermanTeam until 2008. GermanTeam won the world championship three times during its existence. NaoTH participated yearly at the RoboCup competitions since the first SPL competition in 2008 in Suzhou. The most recent achievements include 3rd place in the Outdoor Competition at the RoboCup world championship in 2016 and 2nd place in the Mixed Team Competition as part of the team DoBerMan at the RoboCup 2017. Heinrich Mellmann and Anastasia Prisacaru working on the Gretchen robot. The Gretchen project is a great opportunity for the NaoTH team to apply the acquired knowledge and expertise in programming humanoid robots from the past two decades of competing in RoboCup. The Gretchen robot provides a great platform for experiments and research, since its hardware is completely open source, in contrast to the NAO robots. Our aspiration is to develop the Gretchen robot to the point when it is qualified to join the humanoid legue of the RoboCup Competition.","title":"Introduction"},{"location":"#introduction","text":"An overview of the assembly stages and of the major hardware components.","title":"Introduction"},{"location":"#welcome","text":"Research on embodied artificial intelligence (Embodied AI) based on biological systems is becoming increasingly significant. Biological systems are inherently decentralized, with individual parts of the body having their own intelligence. Intelligent behavior only arises from the interaction of individual components and their interaction with the environment. Hence, the body is an indispensable part of any research of intelligence. Humanoid robots are particularly interesting, however they are still difficult to access, are associated with high costs and often have to be developed by scientists themselves, therby restricting the group of users. In this project we are developing a humanoid robot \u201cGretchen\u201d for research and teaching. Our focus lies on the openness of hardware and software, as well as on the accessibility of the robot for non-specialist researchers. A prototype of the Gretchen robot is already being used in seminars at the Adaptive Systems Group at Humboldt University. The Gretchen robot is a versatile platform for training, as its modular structure enables work and experimentation through hardware design, actuators, 3D printed components, firmware, power supply, communication bus, software libraries or the API. This documentation gives an overview over the current state of the hardware and the software base of the Gretchen robot , as well as brings together all further contributions from various projects and seminars.","title":"Welcome"},{"location":"#the-gretchen-robot","text":"The Gretchen robot was designed and developed by Matthias Kubisch in collaboration with the AI Brain Company in 2018. One of the prototypes of the robot is currently used for academic research and education in the lab of the Adaptive Systems Group in the Computer Science department of the Humboldt University. The Gretchen robot is a versatile platform for education, as its modular design allows working and experimenting by its hardware design, actuators, 3D-printed components, firmware, power supply, communication bus, software libraries or the API. Matthias Kubisch and Gretchen The Gretchen robot is 74 cm high, weighs approximately 5 kg, and has 10 degrees of freedom (DoFs), 5 of which are in each leg: 2 in the hip (roll and pitch), 1 in the knee (pitch), and 2 in the ankle (roll and pitch). The robot resembles the lower part of the human body, by incorporating feet, legs and lower torso as shown in the picture below. Matthias Kubisch and the Gretchen robot The body parts are made from low-cost materials such as wood and 3D-printed components, the CAD files of which can be found on GitHub https://github.com/suprememachines . The robot cannot be purchased, however, it can be manufactured from 3D-printed as well as commercially available materials and electronic components. The Sensorimotor boards are the only components that require custom manufacturing and they can be ordered by using the provided schematic circuits. Gretchen\u2019s overall manufacturing costs lie at roughly 1,400AC.","title":"The Gretchen Robot"},{"location":"#team","text":"The research group NaoTH is part of the research lab for Adaptive Systems at Humboldt-Universit\u00e4t zu Berlin headed by Prof. Verena Hafner. At the current state the core team consists of about 12 students of Bachelor, Master/Diploma, and PhD levels. Besides the direct participation at the RoboCup competitions NaoTH is involved in teaching at the university, public engagement and building of the RoboCup community. The NaoTH Team at Rohow, where the Gretchen robot was introduced to the RoboCup community for the first time. NaoTH was founded at the end of 2007 at the AI research lab headed by Prof. Hans-Dieter Burkhard. As a direct successor of the Aibo Team Humboldt which was active in the Four Legged League of the RoboCup as a part of the GermanTeam until 2008. GermanTeam won the world championship three times during its existence. NaoTH participated yearly at the RoboCup competitions since the first SPL competition in 2008 in Suzhou. The most recent achievements include 3rd place in the Outdoor Competition at the RoboCup world championship in 2016 and 2nd place in the Mixed Team Competition as part of the team DoBerMan at the RoboCup 2017. Heinrich Mellmann and Anastasia Prisacaru working on the Gretchen robot. The Gretchen project is a great opportunity for the NaoTH team to apply the acquired knowledge and expertise in programming humanoid robots from the past two decades of competing in RoboCup. The Gretchen robot provides a great platform for experiments and research, since its hardware is completely open source, in contrast to the NAO robots. Our aspiration is to develop the Gretchen robot to the point when it is qualified to join the humanoid legue of the RoboCup Competition.","title":"Team"},{"location":"10_firmware/","text":"Firmware This section describes the connection between the software and the hardware of the Gretchen robot. The embedded microcontroller on the Sensorimotor board is an important and complex hardware component, which is worth discussing in detail before moving on to the firmware installation and the communication between the boards and the computer. ATmega238P Each servo motor powering the Gretchen robot contains a Sensorimotor board with an embedded ATmega238P , which is a high-performance and open-source single-chip microcontroller created by Atmel and commonly used for open-source projects e.g. Arduino UNO. Its maximum operating frequency amounts 20 MHz and it operates on a voltage ranging from 3.3V to 5.5V . The ATmega238P has several important features, which are relevant to examine in the context of the software of the Gretchen robot, namely: fuses, In-System Programmable Flash, Pulse Width Modulation channels, Serial Communication and Serial-Peripheral-Interface . We elaborate on each of these features in the following subsections. The fuses are 3 bytes, called low, high and extended byte , which store the configuration of the ATmega238P, each bit corresponding to a setting or flag. For all fuses, a value of 1 means not set and a value of 0(zero) means set. The low byte fuse manages the clock settings and speed, as well as the delay after the startup of the microcontroller. The high fuse determines the settings of serial programming and preserving or erasing EEPROM and the bootloader size. The extended fuse ensures that the microcontroller receives enough voltage in order to work properly and it is not set by default. The default fuse settings of the low, high and extended fuses of the ATmega238P are 0x62 (B01100010), 0xD9 (B11011001) and 0xFF (B11111111) respectively. Firmware The firmware is the essential software program or set of instructions running on a microcontroller, which ensures communication with other devices and determines its actions. It is commonly located either in the Electrically Erasable Programmable Read-Only Memory (EEPROM) or in the Flash Memory. Both of them belong to the non-volatile type of memory, meaning that the stored data remains unchanged even after disconnecting the power supply. The main difference between EEPROM and flash memory is that flash memory is block-accessible, meaning that an entire block must be erased before writing, while EEPROM erases one byte at a time. Flash memory is therefore faster and cheaper, however it wears out faster than EEPROM due to a smaller number of write cycles. The EEPROM memory of the ATmega328P microcontroller is 1.024KB and can be rewritten up to 100,000 times, while its flash memory is 32KB and can be rewritten up to 10,000 times. Due to the fact that the firmware is commonly uploaded on the flash memory, this process is often called \"flashing the firmware\". In-System Programming In-System Programming (ISP) allows programming microcontrollers or other embedded devices, without removing them from the board. The Serial-Peripheral-Interface (SPI) provides the communication between the microcontroller and the computer and it consists of 3 wires : Serial Clock (SCK) , Master In \u2013 Slave Out (MISO) , and Master Out \u2013 Slave In (MOSI) . The clock line synchronizes the communication between the computer (master) and the target system (slave), so that at each pulse of the clock line, the microcontroller receives one bit through the MOSI line and simultaneously sends one bit to the computer through the MISO line. The ISP header has 3 additional pins besides the ones of the SPI, namely: Reset , Power (5V) and Ground (GND) . The Reset line is controlled by the master and ensures that once the communication has started it\u2019s not interrupted. For transferring the desired firmware to the microcontroller, we used an AVR-ISP MySmartUSB Light Programmer , which is illustrated in the upper part of figure below. Due to the 5V and the GND pins an external power supply is not necessary , as the programmer draws enough power from the computer for supplying the microcontroller with sufficient voltage to ensure its proper functionality. Firmware Tests The assembly process of the actuators involves several steps which require precision and very careful actions, in order to avoid accidental damage of the boards. For instance, the soldering process of the capacitor involved heating the board for a longer time, as the ground pin was sinking a lot of heat into the board. Moreover, the board LEDs are located very close to the capacitor pins and can be easily damaged by the soldering iron if it slips a few millimeters away. Furthermore, the 3D-printed motor lid can damage the insulation of the motor cables, if the temperature sensor is slightly shifted, potentially causing unexpected behaviors of the board or short circuits. Thus, it is essential to test the boards\u2019 functionality before uploading the firmware and connecting it to the serial bus . The blinky test script, which can be found in the Sensorimotor repository , provides the possibility to check if the board electronics are intact , if the on-board microcontroller can be connected to the computer and respond to basic requests, if its LEDs are intact and if the serial bus and ISP work. The advantage of using a test script as blinky is that no other tools are required to test if the hardware works properly. Additionally, blinky changes the default values of the fuses . The default value of the low byte fuse of the Atmega328p is changed from 0x62 to 0xCF, meaning that the clock speed will be bigger than 8MHz (instead of dividing it by 8), there will be no clock output and the chip will startup with a small delay. The high byte remains unchanged at 0xD9, meaning that serial programming is allowed, the EEPROM memory is preserved and the bootloader has a maximum size of 4KB. The extended fuse is changed to 0xFD, which signifies that the minimal voltage limit is 2,7V. We uploaded the blinky test script to the ATmega238P via the AVR Programmer . The programmer supplies the board with 5V, which is enough for successfully transferring the code to the chip , but not enough for powering the on-board LEDs . In order to check if the test ran successfully and the LEDs were blinking, we had to plug in one RS485 connector with the battery, as shown on the bottom part of figure below. After this step, the firmware can be safely flashed on the microcontroller. The communication channels between the servos with embedded Sensorimotor boards and the computer: On the top part - the USB to ISP Programmer is shown, which is used for the process of flashing the firmware. The bottom part illustrates the communication between the computer and the robot\u2019s serial bus via a USB to Serial Bridge and a power supply attached to it. RS-485 Bus The motors are connected with each other in a daisy-chained manner and communicate with each other and the external computer via the RS-485 serial bus . RS-485 is a data transmission standard for serial communication, which allows for robust transmission of moderate data rates over long distances. It consists of 4 lines : power (VCC), ground (GND), data lines A and B . The RS485 network uses differential communication of two data lines , meaning that the voltage of the data line A is the inverse of the one on the line B . In other words, the same signal is passed through both lines, however, on one line it is inverted, thereby making the bus immune against noise . The output of the receiver is 1 if the voltage of data line A is 200mV bigger than the one of B, and 0 - otherwise. The RS-485 bus lets up to 32 devices to communicate via a single pair of wires , allowing only one device to communicate with the other ones via the bus at a time, with a data rate of 100Hz (10ms) per cycle . There are multiple options of connecting the external computer to the serial bus of the robot, by using a USB-to-Serial/RS485 device, such as FTDI USB-RS485-PCB, Digitus DA-70157 or In-Circuit USB-RS485-Bridge. We used the In-Circuit USB-RS485-Bridge by connecting it to the robot\u2019s foot. As opposed to the other USB-to-Serial devices mentioned above, the USB-RS485-Bridge has only the 3 IO pins which are needed to connect to the robot\u2019s bus: RS485-A, RS485-B and Ground . We have soldered the ground cables of the USB-RS485-Bridge and of a battery, and created a USB-to-Serial connector which is illustrated on the lower part of the figure above. Pulse Width Modulation The actuators of the Gretchen robot are controlled by Pulse Width Modulation (PWM) , which is a commonly used control approach of powering brushed DC motors of legged robots and robotic arms . PWM is a technique of digitally encoding analog signals by chopping an electrical signal in discrete parts. The voltage and the current are controlled by turning the power on and off at a fast rate . The period of time in which the power is turned on - is called a duty cycle . For instance, if the power is on 20% and off - 80% of the time, the PWM output is at a 20% duty cycle. The advantage of the PWM is that it eliminates the need for a digital-to-analog conversion . Due to the fact that the signal remains digital all the way from the processor to the controlled system, the noise effects are minimized , as the noise has to be strong enough to change a logical 1 to 0, or the other way around. The maximally allowed PWM duty cycle is used for setting the voltage limit with which the actuators of the Gretchen robot are powered.","title":"Firmware"},{"location":"10_firmware/#firmware","text":"This section describes the connection between the software and the hardware of the Gretchen robot. The embedded microcontroller on the Sensorimotor board is an important and complex hardware component, which is worth discussing in detail before moving on to the firmware installation and the communication between the boards and the computer.","title":"Firmware"},{"location":"10_firmware/#atmega238p","text":"Each servo motor powering the Gretchen robot contains a Sensorimotor board with an embedded ATmega238P , which is a high-performance and open-source single-chip microcontroller created by Atmel and commonly used for open-source projects e.g. Arduino UNO. Its maximum operating frequency amounts 20 MHz and it operates on a voltage ranging from 3.3V to 5.5V . The ATmega238P has several important features, which are relevant to examine in the context of the software of the Gretchen robot, namely: fuses, In-System Programmable Flash, Pulse Width Modulation channels, Serial Communication and Serial-Peripheral-Interface . We elaborate on each of these features in the following subsections. The fuses are 3 bytes, called low, high and extended byte , which store the configuration of the ATmega238P, each bit corresponding to a setting or flag. For all fuses, a value of 1 means not set and a value of 0(zero) means set. The low byte fuse manages the clock settings and speed, as well as the delay after the startup of the microcontroller. The high fuse determines the settings of serial programming and preserving or erasing EEPROM and the bootloader size. The extended fuse ensures that the microcontroller receives enough voltage in order to work properly and it is not set by default. The default fuse settings of the low, high and extended fuses of the ATmega238P are 0x62 (B01100010), 0xD9 (B11011001) and 0xFF (B11111111) respectively.","title":"ATmega238P"},{"location":"10_firmware/#firmware_1","text":"The firmware is the essential software program or set of instructions running on a microcontroller, which ensures communication with other devices and determines its actions. It is commonly located either in the Electrically Erasable Programmable Read-Only Memory (EEPROM) or in the Flash Memory. Both of them belong to the non-volatile type of memory, meaning that the stored data remains unchanged even after disconnecting the power supply. The main difference between EEPROM and flash memory is that flash memory is block-accessible, meaning that an entire block must be erased before writing, while EEPROM erases one byte at a time. Flash memory is therefore faster and cheaper, however it wears out faster than EEPROM due to a smaller number of write cycles. The EEPROM memory of the ATmega328P microcontroller is 1.024KB and can be rewritten up to 100,000 times, while its flash memory is 32KB and can be rewritten up to 10,000 times. Due to the fact that the firmware is commonly uploaded on the flash memory, this process is often called \"flashing the firmware\".","title":"Firmware"},{"location":"10_firmware/#in-system-programming","text":"In-System Programming (ISP) allows programming microcontrollers or other embedded devices, without removing them from the board. The Serial-Peripheral-Interface (SPI) provides the communication between the microcontroller and the computer and it consists of 3 wires : Serial Clock (SCK) , Master In \u2013 Slave Out (MISO) , and Master Out \u2013 Slave In (MOSI) . The clock line synchronizes the communication between the computer (master) and the target system (slave), so that at each pulse of the clock line, the microcontroller receives one bit through the MOSI line and simultaneously sends one bit to the computer through the MISO line. The ISP header has 3 additional pins besides the ones of the SPI, namely: Reset , Power (5V) and Ground (GND) . The Reset line is controlled by the master and ensures that once the communication has started it\u2019s not interrupted. For transferring the desired firmware to the microcontroller, we used an AVR-ISP MySmartUSB Light Programmer , which is illustrated in the upper part of figure below. Due to the 5V and the GND pins an external power supply is not necessary , as the programmer draws enough power from the computer for supplying the microcontroller with sufficient voltage to ensure its proper functionality.","title":"In-System Programming"},{"location":"10_firmware/#firmware-tests","text":"The assembly process of the actuators involves several steps which require precision and very careful actions, in order to avoid accidental damage of the boards. For instance, the soldering process of the capacitor involved heating the board for a longer time, as the ground pin was sinking a lot of heat into the board. Moreover, the board LEDs are located very close to the capacitor pins and can be easily damaged by the soldering iron if it slips a few millimeters away. Furthermore, the 3D-printed motor lid can damage the insulation of the motor cables, if the temperature sensor is slightly shifted, potentially causing unexpected behaviors of the board or short circuits. Thus, it is essential to test the boards\u2019 functionality before uploading the firmware and connecting it to the serial bus . The blinky test script, which can be found in the Sensorimotor repository , provides the possibility to check if the board electronics are intact , if the on-board microcontroller can be connected to the computer and respond to basic requests, if its LEDs are intact and if the serial bus and ISP work. The advantage of using a test script as blinky is that no other tools are required to test if the hardware works properly. Additionally, blinky changes the default values of the fuses . The default value of the low byte fuse of the Atmega328p is changed from 0x62 to 0xCF, meaning that the clock speed will be bigger than 8MHz (instead of dividing it by 8), there will be no clock output and the chip will startup with a small delay. The high byte remains unchanged at 0xD9, meaning that serial programming is allowed, the EEPROM memory is preserved and the bootloader has a maximum size of 4KB. The extended fuse is changed to 0xFD, which signifies that the minimal voltage limit is 2,7V. We uploaded the blinky test script to the ATmega238P via the AVR Programmer . The programmer supplies the board with 5V, which is enough for successfully transferring the code to the chip , but not enough for powering the on-board LEDs . In order to check if the test ran successfully and the LEDs were blinking, we had to plug in one RS485 connector with the battery, as shown on the bottom part of figure below. After this step, the firmware can be safely flashed on the microcontroller. The communication channels between the servos with embedded Sensorimotor boards and the computer: On the top part - the USB to ISP Programmer is shown, which is used for the process of flashing the firmware. The bottom part illustrates the communication between the computer and the robot\u2019s serial bus via a USB to Serial Bridge and a power supply attached to it.","title":"Firmware Tests"},{"location":"10_firmware/#rs-485-bus","text":"The motors are connected with each other in a daisy-chained manner and communicate with each other and the external computer via the RS-485 serial bus . RS-485 is a data transmission standard for serial communication, which allows for robust transmission of moderate data rates over long distances. It consists of 4 lines : power (VCC), ground (GND), data lines A and B . The RS485 network uses differential communication of two data lines , meaning that the voltage of the data line A is the inverse of the one on the line B . In other words, the same signal is passed through both lines, however, on one line it is inverted, thereby making the bus immune against noise . The output of the receiver is 1 if the voltage of data line A is 200mV bigger than the one of B, and 0 - otherwise. The RS-485 bus lets up to 32 devices to communicate via a single pair of wires , allowing only one device to communicate with the other ones via the bus at a time, with a data rate of 100Hz (10ms) per cycle . There are multiple options of connecting the external computer to the serial bus of the robot, by using a USB-to-Serial/RS485 device, such as FTDI USB-RS485-PCB, Digitus DA-70157 or In-Circuit USB-RS485-Bridge. We used the In-Circuit USB-RS485-Bridge by connecting it to the robot\u2019s foot. As opposed to the other USB-to-Serial devices mentioned above, the USB-RS485-Bridge has only the 3 IO pins which are needed to connect to the robot\u2019s bus: RS485-A, RS485-B and Ground . We have soldered the ground cables of the USB-RS485-Bridge and of a battery, and created a USB-to-Serial connector which is illustrated on the lower part of the figure above.","title":"RS-485 Bus"},{"location":"10_firmware/#pulse-width-modulation","text":"The actuators of the Gretchen robot are controlled by Pulse Width Modulation (PWM) , which is a commonly used control approach of powering brushed DC motors of legged robots and robotic arms . PWM is a technique of digitally encoding analog signals by chopping an electrical signal in discrete parts. The voltage and the current are controlled by turning the power on and off at a fast rate . The period of time in which the power is turned on - is called a duty cycle . For instance, if the power is on 20% and off - 80% of the time, the PWM output is at a 20% duty cycle. The advantage of the PWM is that it eliminates the need for a digital-to-analog conversion . Due to the fact that the signal remains digital all the way from the processor to the controlled system, the noise effects are minimized , as the noise has to be strong enough to change a logical 1 to 0, or the other way around. The maximally allowed PWM duty cycle is used for setting the voltage limit with which the actuators of the Gretchen robot are powered.","title":"Pulse Width Modulation"},{"location":"11_motor_control/","text":"Motor Control The actuator of the Gretchen robot can be controlled by the software libraries which run on an external computer with Linux OS . This introduces a significant delay in the control loop because at each time step the motors send commands with their current state to the computer and wait for it to recalculate the data and send the new commands back. In order to minimize the feedback delay between the computer and the servos, it\u2019s important to set the low-latency mode on the computer. However, the low latency mode doesn\u2019t eliminate the feedback delay completely. The movements of the robot are generated by changing the speed and the rotation of the actuators, which are determined by the current and its direction respectively. Conventional microcontrollers can\u2019t pass enough current or voltage for powering a motor, therefore specialized circuits have been developed to supply motors with power and protect the microcontrollers from additional electrical problems , one of the being the H-bridge . H-Bridge An H-bridge is a widely used circuit for powering DC motors, which uses 4 switches for managing the direction and the speed of a motor . The \u2019H\u2019 signifies the shape of the circuit, as the four switches are placed pairwise in series and in parallel, with the motor placed in the middle. The Sensorimotor boards have an integrated H-Bridge which receives as input a PWM and a direction signal and can handle up to 6A. Controllers Calculating the input values for the H-Bridge is not a trivial task and there are several approaches for controlling the motors, the most common ones being position, velocity and torque control . The position control mechanism is easy for humans to comprehend because the position is a physical variable more commonly used in the real world than torque or velocity. Torque control is a method of moving the actuators by working with voltage and the current , instead of the position. Velocity control , as the name suggests, calculates the speed of the motor by comparing the desired velocity with the measured velocity . Due to the open-source nature of the Gretchen robot, it allows a big room for experiments and for trying out alternative controllers. For instance, the Libsensorimotor repository contains the implementation of a Cognitive Sensorimotor Loop (CSL) controller, which is a novel, computationally simplistic, and energy-efficient approach of making a humanoid robot to stand up from various postures. It does not require any additional sensors - the motor itself serves both as actuator and sensor . PID Controller The Libsensorimotor repository contains the C++ implementation of a position control mechanism , namely, the proportional-integral-derivative (PID) controller . The motors are sending their position to the computer, where the PID controller calculates the next position and sends it back to each of the motors at a rate of 100Hz until the desired positions are achieved. A PID controller is the most commonly used control loop mechanism due to its simple implementation, clear functionality, and a wide range of applications . Its transfer function is shown below where \\(e(t)\\) is the error, \\(K_p\\) , \\(K_i\\) and \\(K_d\\) are the proportional, integral and derivative parameters respectively. The error value indicates the difference between the desired position, also called setpoint, and the current position of the motor. The goal of the controller is to minimize the error by adjusting the control variable \\(u(t)\\) . The proportional term , as the name suggests, changes the controller output in proportion to the error, so the bigger the error - the greater the control action. If a controller is using only the proportional term, meaning that the other ones are set to zero, the end value will oscillate around the required position , but depending on the parameter there might always be an error. This problem is well known as the steady-state error and it can be minimized by the integral term . As long as the error is positive, the integral term will keep incrementing the rate of the control output, and otherwise - will be decrementing it, until the error is zero. The derivative term reacts to the rate of change of the error , meaning that once the error is being minimized with fast speed, the derivative term will gradually decrease the speed of the motor and prevent it from passing over the desired position . The three parameters of the PID controller require tuning , which is an important process, as the speed and the electric draw of the motors depend on them. Another term that can be used for increasing the service life of the actuators and enhancing the controller\u2019s efficacy is the deadband . The deadband is a constant which is subtracted from the error value in order to limit the lower end of the voltage output. In other words, if the error value is smaller than the deadband, the error will be set to 0 and the controller will stop the motors at that position. This approach prevents the actuators from infinitely trying to reach a setpoint to which they are very close, but cannot reach for some reason.","title":"Motor Control"},{"location":"11_motor_control/#motor-control","text":"The actuator of the Gretchen robot can be controlled by the software libraries which run on an external computer with Linux OS . This introduces a significant delay in the control loop because at each time step the motors send commands with their current state to the computer and wait for it to recalculate the data and send the new commands back. In order to minimize the feedback delay between the computer and the servos, it\u2019s important to set the low-latency mode on the computer. However, the low latency mode doesn\u2019t eliminate the feedback delay completely. The movements of the robot are generated by changing the speed and the rotation of the actuators, which are determined by the current and its direction respectively. Conventional microcontrollers can\u2019t pass enough current or voltage for powering a motor, therefore specialized circuits have been developed to supply motors with power and protect the microcontrollers from additional electrical problems , one of the being the H-bridge .","title":"Motor Control"},{"location":"11_motor_control/#h-bridge","text":"An H-bridge is a widely used circuit for powering DC motors, which uses 4 switches for managing the direction and the speed of a motor . The \u2019H\u2019 signifies the shape of the circuit, as the four switches are placed pairwise in series and in parallel, with the motor placed in the middle. The Sensorimotor boards have an integrated H-Bridge which receives as input a PWM and a direction signal and can handle up to 6A.","title":"H-Bridge"},{"location":"11_motor_control/#controllers","text":"Calculating the input values for the H-Bridge is not a trivial task and there are several approaches for controlling the motors, the most common ones being position, velocity and torque control . The position control mechanism is easy for humans to comprehend because the position is a physical variable more commonly used in the real world than torque or velocity. Torque control is a method of moving the actuators by working with voltage and the current , instead of the position. Velocity control , as the name suggests, calculates the speed of the motor by comparing the desired velocity with the measured velocity . Due to the open-source nature of the Gretchen robot, it allows a big room for experiments and for trying out alternative controllers. For instance, the Libsensorimotor repository contains the implementation of a Cognitive Sensorimotor Loop (CSL) controller, which is a novel, computationally simplistic, and energy-efficient approach of making a humanoid robot to stand up from various postures. It does not require any additional sensors - the motor itself serves both as actuator and sensor .","title":"Controllers"},{"location":"11_motor_control/#pid-controller","text":"The Libsensorimotor repository contains the C++ implementation of a position control mechanism , namely, the proportional-integral-derivative (PID) controller . The motors are sending their position to the computer, where the PID controller calculates the next position and sends it back to each of the motors at a rate of 100Hz until the desired positions are achieved. A PID controller is the most commonly used control loop mechanism due to its simple implementation, clear functionality, and a wide range of applications . Its transfer function is shown below where \\(e(t)\\) is the error, \\(K_p\\) , \\(K_i\\) and \\(K_d\\) are the proportional, integral and derivative parameters respectively. The error value indicates the difference between the desired position, also called setpoint, and the current position of the motor. The goal of the controller is to minimize the error by adjusting the control variable \\(u(t)\\) . The proportional term , as the name suggests, changes the controller output in proportion to the error, so the bigger the error - the greater the control action. If a controller is using only the proportional term, meaning that the other ones are set to zero, the end value will oscillate around the required position , but depending on the parameter there might always be an error. This problem is well known as the steady-state error and it can be minimized by the integral term . As long as the error is positive, the integral term will keep incrementing the rate of the control output, and otherwise - will be decrementing it, until the error is zero. The derivative term reacts to the rate of change of the error , meaning that once the error is being minimized with fast speed, the derivative term will gradually decrease the speed of the motor and prevent it from passing over the desired position . The three parameters of the PID controller require tuning , which is an important process, as the speed and the electric draw of the motors depend on them. Another term that can be used for increasing the service life of the actuators and enhancing the controller\u2019s efficacy is the deadband . The deadband is a constant which is subtracted from the error value in order to limit the lower end of the voltage output. In other words, if the error value is smaller than the deadband, the error will be set to 0 and the controller will stop the motors at that position. This approach prevents the actuators from infinitely trying to reach a setpoint to which they are very close, but cannot reach for some reason.","title":"PID Controller"},{"location":"12_libsensorimotor/","text":"Libsensorimotor - Python API In this section, we describe the setup and the structure of a few experiments on position control. Our first experiments show that the robot can be used for experimenting with various control approaches and that the motors are strong enough to make the robot stand up and perform basic motions . Motorcord The Python API of the Libsensorimotor library provides a possibility for high-level control of a series of motors equipped with the Sensorimotor boards and connected in a chain. We refer to the chain of motors connected via the RS485 bus as Motorcord . The IDs of the motors in the chain have to be set in sequence beginning with 0 (zero). We labeled the motors with numbers from 0 to 9 (see picture below) and have set the corresponding ID for each motor by using the set_id.py script available in the Sensorimotor repository](https://github.com/suprememachines/sensorimotor/tree/3a87a29950bdd637be39ed34af577aef0984a3cb). In the following paragraphs, we elaborate on the process of creating the motorcord and controlling the motors based on the position control approach. The following line in Python instantiates the connection to the robot\u2019s chain of motors: motors = Sensorimotor ( number_of_motors = 10, update_rate_Hz = 100 , verbose = True ) The parameters update_rate_Hz \\(= 100\\) and verbose \\(= True\\) are default values and do not need to be set explicitly. In order to verify that all motors in the chain respond correctly we can use the function ping: n = motors.ping() The returned number \\(n\\) indicates the number of motors that did respond . In the case of Gretchen, the expected number would be \\(n = 10\\) . The class Sensorimotor provides an internal loop which realizes the communication with the motors. In each frame of the loop, new motor commands are sent to the motors and new sensor data is retrieved. The internal loop runs as an independent thread and can be started and stopped with the following commands: motors.start() motors.stop() The function get_position reads out the positions of the motors , as measured by the position sensors: The returned value \\(s\\) is a list containing the positions of the motors in radiant as floating numbers. The length of the list corresponds to the number of motors in the chain and the position in the list corresponds to the ID of the corresponding motor , i.e., in the above example \\(s[3]\\) is the angular position of the third motor. In our experiments, we use the position control as described in Section about the PID Controller. The target positions for the motors can be set with the following function: motors.set_position(p) Thereby \\(p\\) is a list of target angular positions for each of the motors in radiant as a floating number. The following simple example demonstrates setting the positions of all motors of the Gretchen robot to 0: p = [0.f ,0.f ,0.f ,0.f ,0.f ,0.f ,0.f ,0.f ,0.f ,0.f] motors.set_position(p) A complete basic control loop has the following form: motors = Sensorimotor ( number_of_motors =10) motors.start() while(True): s = motors.get_position() # do something with the positions \u2018s\u2018 and # calculate new target values for the motors \u2018p\u2018 motors.set_position(p) sleep(0.01) motors.stop() The above loop is executed independently of the internal communication loop . The functions get_position and set_position are non-blocking, which makes it necessary to artificially pause the control loop with the \\(sleep(0.001)\\) function, in order to wait for the internal loop to finish execution. This makes the control-loop robust since the internal communication is not interrupted in case the calculations in the main loop take longer than permitted by the frame rate (in our case 10ms). In the future, the API should be extended with functionality which would also allow synchronizing the main loop with the internal communication loop, in order to ensure precise control of the motors\u2019 positions.","title":"Libsensorimotor - Python API"},{"location":"12_libsensorimotor/#libsensorimotor-python-api","text":"In this section, we describe the setup and the structure of a few experiments on position control. Our first experiments show that the robot can be used for experimenting with various control approaches and that the motors are strong enough to make the robot stand up and perform basic motions .","title":"Libsensorimotor - Python API"},{"location":"12_libsensorimotor/#motorcord","text":"The Python API of the Libsensorimotor library provides a possibility for high-level control of a series of motors equipped with the Sensorimotor boards and connected in a chain. We refer to the chain of motors connected via the RS485 bus as Motorcord . The IDs of the motors in the chain have to be set in sequence beginning with 0 (zero). We labeled the motors with numbers from 0 to 9 (see picture below) and have set the corresponding ID for each motor by using the set_id.py script available in the Sensorimotor repository](https://github.com/suprememachines/sensorimotor/tree/3a87a29950bdd637be39ed34af577aef0984a3cb). In the following paragraphs, we elaborate on the process of creating the motorcord and controlling the motors based on the position control approach. The following line in Python instantiates the connection to the robot\u2019s chain of motors: motors = Sensorimotor ( number_of_motors = 10, update_rate_Hz = 100 , verbose = True ) The parameters update_rate_Hz \\(= 100\\) and verbose \\(= True\\) are default values and do not need to be set explicitly. In order to verify that all motors in the chain respond correctly we can use the function ping: n = motors.ping() The returned number \\(n\\) indicates the number of motors that did respond . In the case of Gretchen, the expected number would be \\(n = 10\\) . The class Sensorimotor provides an internal loop which realizes the communication with the motors. In each frame of the loop, new motor commands are sent to the motors and new sensor data is retrieved. The internal loop runs as an independent thread and can be started and stopped with the following commands: motors.start() motors.stop() The function get_position reads out the positions of the motors , as measured by the position sensors: The returned value \\(s\\) is a list containing the positions of the motors in radiant as floating numbers. The length of the list corresponds to the number of motors in the chain and the position in the list corresponds to the ID of the corresponding motor , i.e., in the above example \\(s[3]\\) is the angular position of the third motor. In our experiments, we use the position control as described in Section about the PID Controller. The target positions for the motors can be set with the following function: motors.set_position(p) Thereby \\(p\\) is a list of target angular positions for each of the motors in radiant as a floating number. The following simple example demonstrates setting the positions of all motors of the Gretchen robot to 0: p = [0.f ,0.f ,0.f ,0.f ,0.f ,0.f ,0.f ,0.f ,0.f ,0.f] motors.set_position(p) A complete basic control loop has the following form: motors = Sensorimotor ( number_of_motors =10) motors.start() while(True): s = motors.get_position() # do something with the positions \u2018s\u2018 and # calculate new target values for the motors \u2018p\u2018 motors.set_position(p) sleep(0.01) motors.stop() The above loop is executed independently of the internal communication loop . The functions get_position and set_position are non-blocking, which makes it necessary to artificially pause the control loop with the \\(sleep(0.001)\\) function, in order to wait for the internal loop to finish execution. This makes the control-loop robust since the internal communication is not interrupted in case the calculations in the main loop take longer than permitted by the frame rate (in our case 10ms). In the future, the API should be extended with functionality which would also allow synchronizing the main loop with the internal communication loop, in order to ensure precise control of the motors\u2019 positions.","title":"Motorcord"},{"location":"13_webots/","text":"Webots Simulation","title":"Webots Simulation"},{"location":"13_webots/#webots-simulation","text":"","title":"Webots Simulation"},{"location":"14_current_progress/","text":"Current Progress A timeline with all projects with the Gretchen Robot is shown below:","title":"Current Progress"},{"location":"14_current_progress/#current-progress","text":"A timeline with all projects with the Gretchen Robot is shown below:","title":"Current Progress"},{"location":"15_conferences/","text":"Conferences One of the future goals of the Gretchen robot is joining the Humanoid League of RoboCup and driving collaboration with the other teams who have extensive experience in designing and manufacturing humanoid robots. The Gretchen robot has already been demonstrated at two events organized by the RoboCup community . RoHOW The first public appearance of the Gretchen robot was at the Robotic Hamburg Open Workshop (RoHOW) , to which we traveled with the Berlin United Team from the Humboldt University. The RoHOW is an educational and networking event of the Hamburg University of Technology (TUHH) with students and scientists from all over the world that are active in research on humanoid robots. The researchers and students from other teams showed great interest in the Gretchen robot, especially in its actuators powered by the Sensorimotor boards. In the left photo below, the Gretchen robot is sitting next to the Hambot robot from the Bit-Bots team from the University of Hamburg, which was the only team from the Humanoid League of RoboCup at the RoHOW. We exchanged experience with each other and discussed collaboration ideas and the potential of the Gretchen robot for joining the Humanoid League of RoboCup. The photo below shows the members of the Berlin United Team from the Humboldt University who attended the RoHOW, with the Nao and Gretchen robots sitting on the laps of two team members. The NaoTH Team at Rohow, where the Gretchen robot was introduced to the RoboCup community for the first time. V-RoHOW We have also presented the Gretchen robot in a 60-minute talk at the Virtual RoboCup Humanoid Open Workshops (V-RoHOW) , together with Heinrich Mellmann and Matthias Kubisch. V-RoHOW is an online workspace for the RoboCup Humanoid community to get together, pitch ideas and socialize. This online event was organized for the first time, due to the cancellation of RoboCup 2020. Our presentation was called \u2019Gretchen - a Humanoid Open Hardware Platform for Education and Research\u2019 , where we presented the current state of the Gretchen project, some of the robot\u2019s most interesting hardware features, the software architecture, and the Sensorimotor boards. In the 15-minute discussion after our talk, questions about the Sensorimotor boards were asked and discussed, namely about the board microcontroller, serial bus and its cables, and the features of the boards. The talk was recorded and published on YouTube . Forum Junge Spitzenforscher Once a year, the Foundation for Industrial Research and the Berlin universities look for young scientists with original and practical ideas and solutions that have emerged from their innovative basic research as part of the science competition \u201cForum Junge Spitzenforscher\u201d. On November 18, 2020, the virtual closing event (see pictures below) and awarding of the winners took place in cooperation with Humboldt Innovation. The project \"Volksbot: Gretchen\" got into the final round and won a prize.","title":"Conferences"},{"location":"15_conferences/#conferences","text":"One of the future goals of the Gretchen robot is joining the Humanoid League of RoboCup and driving collaboration with the other teams who have extensive experience in designing and manufacturing humanoid robots. The Gretchen robot has already been demonstrated at two events organized by the RoboCup community .","title":"Conferences"},{"location":"15_conferences/#rohow","text":"The first public appearance of the Gretchen robot was at the Robotic Hamburg Open Workshop (RoHOW) , to which we traveled with the Berlin United Team from the Humboldt University. The RoHOW is an educational and networking event of the Hamburg University of Technology (TUHH) with students and scientists from all over the world that are active in research on humanoid robots. The researchers and students from other teams showed great interest in the Gretchen robot, especially in its actuators powered by the Sensorimotor boards. In the left photo below, the Gretchen robot is sitting next to the Hambot robot from the Bit-Bots team from the University of Hamburg, which was the only team from the Humanoid League of RoboCup at the RoHOW. We exchanged experience with each other and discussed collaboration ideas and the potential of the Gretchen robot for joining the Humanoid League of RoboCup. The photo below shows the members of the Berlin United Team from the Humboldt University who attended the RoHOW, with the Nao and Gretchen robots sitting on the laps of two team members. The NaoTH Team at Rohow, where the Gretchen robot was introduced to the RoboCup community for the first time.","title":"RoHOW"},{"location":"15_conferences/#v-rohow","text":"We have also presented the Gretchen robot in a 60-minute talk at the Virtual RoboCup Humanoid Open Workshops (V-RoHOW) , together with Heinrich Mellmann and Matthias Kubisch. V-RoHOW is an online workspace for the RoboCup Humanoid community to get together, pitch ideas and socialize. This online event was organized for the first time, due to the cancellation of RoboCup 2020. Our presentation was called \u2019Gretchen - a Humanoid Open Hardware Platform for Education and Research\u2019 , where we presented the current state of the Gretchen project, some of the robot\u2019s most interesting hardware features, the software architecture, and the Sensorimotor boards. In the 15-minute discussion after our talk, questions about the Sensorimotor boards were asked and discussed, namely about the board microcontroller, serial bus and its cables, and the features of the boards. The talk was recorded and published on YouTube .","title":"V-RoHOW"},{"location":"15_conferences/#forum-junge-spitzenforscher","text":"Once a year, the Foundation for Industrial Research and the Berlin universities look for young scientists with original and practical ideas and solutions that have emerged from their innovative basic research as part of the science competition \u201cForum Junge Spitzenforscher\u201d. On November 18, 2020, the virtual closing event (see pictures below) and awarding of the winners took place in cooperation with Humboldt Innovation. The project \"Volksbot: Gretchen\" got into the final round and won a prize.","title":"Forum Junge Spitzenforscher"},{"location":"16_projects/","text":"University Projects Proseminar Humanoid Robots (SoSe20) In this Repository all contributions, code and the final paper can be found. Simulation in Webots Any humanoid robot can benefit from having a corresponding 3D-model simulation, which can be used for testing new software and experimenting with various behaviors and motions, with no hardware exploitation. The simulation software would also enable the use of the robot in educational projects for bigger groups of students, where there\u2019s no possibility of providing each person with a robot. During the proseminar, a 3D-model of the Gretchen robot was created inside the Webots simulation environment. The students used the CAD data in .f3d format of the individual components available in the Gretchen Git to determine the exact dimensions and then transfer them to the Webots model. They have also programmed short scripts in order to test the proper funtionality of the 3D-model, namely the motor control, all degrees of freedom and the fuctionality of the bounding boxes as a limitation for interaction between body parts. Extended firmware One of the limitations of the robot was that the controllers were implemented in the Libsensorimotor module and were therefore executed on an external computer. This introduces a significant delay in the control loop because at each time step the motors send commands with their current state to the computer and wait for it to recalculate the data and send the new commands back (as shown in the left figure below). One possible solution that doesn\u2019t involve any additional hardware is running the PID controller directly on the ATmega238P microcontroller. The firmware of the robot is completely customizable and the embedded microcontroller of each motor delivers enough performance to perform more complex calculations. Therefore, the RS-485 bus control could be handled directly by the firmware, if the controller software runs directly on them. The seminar participants extended the firmware of the Sensorimotor board with the PID controller, as ilustrated in the right figure below. Left sequence diagram: PID controller running on a Linux machine. Right sequence diagram: PID controller running on firmare. Semester Project Humanoid Robots (WiSe20) During the winter semester 20/21 four groups of students were working on different projects linked with the Gretchen project as a part of the Semester Project \"Humanoid Robots\". Below are listed the achieved results and builds. In this Repository all contributions, code and the final paper can be found. A new hip joint design with 3 DOFs In the current hardware configuration of the Gretchen robot, the hip joint lacks one degree of freedom - the yaw, meaning that the robot can only walk forward and backward and cannot turn around its rotational axis. A group of student tried to make a new design of the hip joint with 3 DOFs and 3D-printed the first prototype, shown in the picture below. PID controller running on firmware 3D-printed eye for visual processing Improved Webots simulation","title":"University Projects"},{"location":"16_projects/#university-projects","text":"","title":"University Projects"},{"location":"16_projects/#proseminar-humanoid-robots-sose20","text":"In this Repository all contributions, code and the final paper can be found.","title":"Proseminar Humanoid Robots (SoSe20)"},{"location":"16_projects/#simulation-in-webots","text":"Any humanoid robot can benefit from having a corresponding 3D-model simulation, which can be used for testing new software and experimenting with various behaviors and motions, with no hardware exploitation. The simulation software would also enable the use of the robot in educational projects for bigger groups of students, where there\u2019s no possibility of providing each person with a robot. During the proseminar, a 3D-model of the Gretchen robot was created inside the Webots simulation environment. The students used the CAD data in .f3d format of the individual components available in the Gretchen Git to determine the exact dimensions and then transfer them to the Webots model. They have also programmed short scripts in order to test the proper funtionality of the 3D-model, namely the motor control, all degrees of freedom and the fuctionality of the bounding boxes as a limitation for interaction between body parts.","title":"Simulation in Webots"},{"location":"16_projects/#extended-firmware","text":"One of the limitations of the robot was that the controllers were implemented in the Libsensorimotor module and were therefore executed on an external computer. This introduces a significant delay in the control loop because at each time step the motors send commands with their current state to the computer and wait for it to recalculate the data and send the new commands back (as shown in the left figure below). One possible solution that doesn\u2019t involve any additional hardware is running the PID controller directly on the ATmega238P microcontroller. The firmware of the robot is completely customizable and the embedded microcontroller of each motor delivers enough performance to perform more complex calculations. Therefore, the RS-485 bus control could be handled directly by the firmware, if the controller software runs directly on them. The seminar participants extended the firmware of the Sensorimotor board with the PID controller, as ilustrated in the right figure below. Left sequence diagram: PID controller running on a Linux machine. Right sequence diagram: PID controller running on firmare.","title":"Extended firmware"},{"location":"16_projects/#semester-project-humanoid-robots-wise20","text":"During the winter semester 20/21 four groups of students were working on different projects linked with the Gretchen project as a part of the Semester Project \"Humanoid Robots\". Below are listed the achieved results and builds. In this Repository all contributions, code and the final paper can be found.","title":"Semester Project Humanoid Robots (WiSe20)"},{"location":"16_projects/#a-new-hip-joint-design-with-3-dofs","text":"In the current hardware configuration of the Gretchen robot, the hip joint lacks one degree of freedom - the yaw, meaning that the robot can only walk forward and backward and cannot turn around its rotational axis. A group of student tried to make a new design of the hip joint with 3 DOFs and 3D-printed the first prototype, shown in the picture below.","title":"A new hip joint design with 3 DOFs"},{"location":"16_projects/#pid-controller-running-on-firmware","text":"","title":"PID controller running on firmware"},{"location":"16_projects/#3d-printed-eye-for-visual-processing","text":"","title":"3D-printed eye for visual processing"},{"location":"16_projects/#improved-webots-simulation","text":"","title":"Improved Webots simulation"},{"location":"17_links/","text":"Useful Links General information about Gretchen: BerlinUnited GitHub Repository: https://github.com/BerlinUnited/Gretchen Gretchen Page on the BerlinUnited website (in German): https://berlin-united.org/project-gretchen.html Gretchen documentation TBD: Initial assembly Documentation by Matthias Kubisch: https://github.com/aibrainag/Gretchen/blob/master/documentation/documentation.adoc Repositories for university projects: Proseminar Humanoid Robots (SoSe20): https://scm.cms.hu-berlin.de/adapt/teaching/ss20-shr/5-gretchen/-/tree/master Semester Project Humanoid Robots (WiSe20): https://scm.cms.hu-berlin.de/adapt/teaching/ws20-sphr Theses and seminar papers: Bachelor Thesis \"Gretchen - a humanoid robot for research and education\" by Anastasia Prisacaru: https://www.naoteamhumboldt.de/wp-content/papercite-data/pdf/2020_prisacaru_bachelorarbeit.pdf Seminar paper about extended firmware and Webots simulation by Emil Bergold, Jacob D\u00f6ring, Raphael Winkel and Mathias Wolff: https://scm.cms.hu-berlin.de/adapt/teaching/ss20-shr/5-gretchen/-/blob/master/Gretchen____Abschlussbericht.pdf More seminar and semester project papers TBD Conferences: A 60-minute talk at the Virtual RoboCup Humanoid Open Workshops (V-RoHOW), by Heinrich Mellmann, Matthias Kubisch and Anastaisa Prisacaru with the name \"Gretchen - a Humanoid Open Hardware Platform for Education and Research: https://www.youtube.com/watch?v=tsjLt30-Pxw&t=2495s Forum Junge Spitzforscher: video/slides Videos with Gretchen: First steps of Gretchen, an open-source bipedal robot: https://www.youtube.com/watch?v=ubMeLkMhT9Y Robot Gretchen - Stand Up Test after Assembly: https://www.youtube.com/watch?v=Sa2bKjIAHFQ","title":"Useful Links"},{"location":"17_links/#useful-links","text":"General information about Gretchen: BerlinUnited GitHub Repository: https://github.com/BerlinUnited/Gretchen Gretchen Page on the BerlinUnited website (in German): https://berlin-united.org/project-gretchen.html Gretchen documentation TBD: Initial assembly Documentation by Matthias Kubisch: https://github.com/aibrainag/Gretchen/blob/master/documentation/documentation.adoc Repositories for university projects: Proseminar Humanoid Robots (SoSe20): https://scm.cms.hu-berlin.de/adapt/teaching/ss20-shr/5-gretchen/-/tree/master Semester Project Humanoid Robots (WiSe20): https://scm.cms.hu-berlin.de/adapt/teaching/ws20-sphr Theses and seminar papers: Bachelor Thesis \"Gretchen - a humanoid robot for research and education\" by Anastasia Prisacaru: https://www.naoteamhumboldt.de/wp-content/papercite-data/pdf/2020_prisacaru_bachelorarbeit.pdf Seminar paper about extended firmware and Webots simulation by Emil Bergold, Jacob D\u00f6ring, Raphael Winkel and Mathias Wolff: https://scm.cms.hu-berlin.de/adapt/teaching/ss20-shr/5-gretchen/-/blob/master/Gretchen____Abschlussbericht.pdf More seminar and semester project papers TBD Conferences: A 60-minute talk at the Virtual RoboCup Humanoid Open Workshops (V-RoHOW), by Heinrich Mellmann, Matthias Kubisch and Anastaisa Prisacaru with the name \"Gretchen - a Humanoid Open Hardware Platform for Education and Research: https://www.youtube.com/watch?v=tsjLt30-Pxw&t=2495s Forum Junge Spitzforscher: video/slides Videos with Gretchen: First steps of Gretchen, an open-source bipedal robot: https://www.youtube.com/watch?v=ubMeLkMhT9Y Robot Gretchen - Stand Up Test after Assembly: https://www.youtube.com/watch?v=Sa2bKjIAHFQ","title":"Useful Links"},{"location":"2_hardware_intro/","text":"Hardware Introduction The building process of the Gretchen robot can be divided into 3 stages which require different levels of expertise. The first stage includes purchasing all commercially available electronic, wooden, and drive components and ordering the custom boards. The second stage involves manufacturing the body parts by using special equipment such as a laser cutting or milling machine and a 3D-printer. The final stage includes gluing and coloring the wooden parts, soldering the electronic components to the custom boards, assembling the motors, manufacturing the cables, and putting everything together. An overview of the assembly stages and of the major hardware components.","title":"Hardware Introduction"},{"location":"2_hardware_intro/#hardware-introduction","text":"The building process of the Gretchen robot can be divided into 3 stages which require different levels of expertise. The first stage includes purchasing all commercially available electronic, wooden, and drive components and ordering the custom boards. The second stage involves manufacturing the body parts by using special equipment such as a laser cutting or milling machine and a 3D-printer. The final stage includes gluing and coloring the wooden parts, soldering the electronic components to the custom boards, assembling the motors, manufacturing the cables, and putting everything together. An overview of the assembly stages and of the major hardware components.","title":"Hardware Introduction"},{"location":"3_wooden_parts/","text":"Wooden Parts The robot\u2019s body incorporates feet, shanks, thighs and lower torso, which are shown on the right side of Figure 3.1. Gretchen\u2019s legs and lower torso are made of plywood, which is a versatile and low-cost building material made from thin layers of wood veneer glued together [48]. The way plywood is made ensures consistent strength across the entire length of the wood, which makes it resistant to warping, cracking and twisting Left picture: The process of gluing 2 plywood plates together and using small clamps to apply appropriate pressure distributed on the full surface. Right picture: The wooden body parts drying on paper towels, after being painted with yellow color and covered with clear coating. Plywood is the optimal choice of material for Gretchen\u2019s limbs because 3D-printing parts of this size is time-consuming and they wouldn\u2019t fit into a conventional 3D-printer. The assembly documentation states that there are 10 wooden pieces, which need to be glued together pairwise, in order to achieve the needed thickness of 1cm. The reason for this is that the laser cutting machine used for carving the wooden parts, was able to cut through 5mm thick wood surfaces. One can use 1cm wide plywood plates when having access to a more powerful laser cutting or milling machine. The left photo in Figure 3.1 illustrates two wooden plates glued together using small clamps to apply uniform pressure on the full surface. Each side of the wooden body parts is painted with a different color and covered with a few layers of clear coating for protection against humidity and fat. Having the back and the front of the robot painted in different colors is not a compulsory step, but it may ease the assembling process and make the robot more appealing. All wooden parts have either one or two rectangular holes for the servomotors, a few round holes for the cable ties and the bearings. The lower torso has 3 additional rectangular holes, which are designed for grabbing and lifting the robot.","title":"Wooden Parts"},{"location":"3_wooden_parts/#wooden-parts","text":"The robot\u2019s body incorporates feet, shanks, thighs and lower torso, which are shown on the right side of Figure 3.1. Gretchen\u2019s legs and lower torso are made of plywood, which is a versatile and low-cost building material made from thin layers of wood veneer glued together [48]. The way plywood is made ensures consistent strength across the entire length of the wood, which makes it resistant to warping, cracking and twisting Left picture: The process of gluing 2 plywood plates together and using small clamps to apply appropriate pressure distributed on the full surface. Right picture: The wooden body parts drying on paper towels, after being painted with yellow color and covered with clear coating. Plywood is the optimal choice of material for Gretchen\u2019s limbs because 3D-printing parts of this size is time-consuming and they wouldn\u2019t fit into a conventional 3D-printer. The assembly documentation states that there are 10 wooden pieces, which need to be glued together pairwise, in order to achieve the needed thickness of 1cm. The reason for this is that the laser cutting machine used for carving the wooden parts, was able to cut through 5mm thick wood surfaces. One can use 1cm wide plywood plates when having access to a more powerful laser cutting or milling machine. The left photo in Figure 3.1 illustrates two wooden plates glued together using small clamps to apply uniform pressure on the full surface. Each side of the wooden body parts is painted with a different color and covered with a few layers of clear coating for protection against humidity and fat. Having the back and the front of the robot painted in different colors is not a compulsory step, but it may ease the assembling process and make the robot more appealing. All wooden parts have either one or two rectangular holes for the servomotors, a few round holes for the cable ties and the bearings. The lower torso has 3 additional rectangular holes, which are designed for grabbing and lifting the robot.","title":"Wooden Parts"},{"location":"4_drive_parts/","text":"Drive Parts Drive parts include all moving components which ensure that the body parts and the joints of the robot are able to move or rotate. In this section, we describe the main drive components used for Gretchen: bearings and toothed belts. The assembly documentation only provides information about how to install them. Below we offer a more detailed overview of each drive component. On the left side: Bearings mounted on the wooden parts. On the right side: A toothed belt connecting a joint and an actuator. Bearings The bearings ensure a smooth connection between the joints and the body plates, due to tiny steel balls inside, which allow the parts to roll around each other with reduced friction. The assembly kit contains 20 KFL08 bearings, with the inside diameter of 8mm and two mounting holes. The bearings should be connected in pairs on each side of the wooden plates, as well as on the 3D-printed feet frames. It\u2019s important to place spring washers between the wood and the steel components, in order to protect the surface from damage, distribute the pressure, and prevent the bolts and nuts from moving or corroding. Bearings mounted on the wooden parts, marked with the red circles. Toothed Belts Toothed belts are flexible bands with teeth carved onto their inner surface, designed to run over matching toothed pulleys. These belts ensure an indirect transmission between the joints and the motors, thereby making the connection between them more elastic and protecting the motors from the direct damage of heavy loads. However, this mechanism has a few disadvantages, such as lack of precision due to the mechanical freedom at the connecting points between the joints and the motors; as well as power loss, due to the motion devices between the motor and the joint which need to be moved. The indirect drive mechanism is rarely used in humanoid robotics and therefore represents an interesting research direction, as its elasticity allows more naturally looking movements of the robot. The 3D-printed pulleys of the motors and the joints are connected pairwise via 10 GT3 6mm wide toothed belts, eight of which have the pitch length of 303mm and the other two - 174mm. The position of the timing belts is very important because they define the movement ratio of the servos. Therefore, Matthias Kubisch recorded a helpful video where the installation of the toothed belts is demonstrated:","title":"Drive Parts"},{"location":"4_drive_parts/#drive-parts","text":"Drive parts include all moving components which ensure that the body parts and the joints of the robot are able to move or rotate. In this section, we describe the main drive components used for Gretchen: bearings and toothed belts. The assembly documentation only provides information about how to install them. Below we offer a more detailed overview of each drive component. On the left side: Bearings mounted on the wooden parts. On the right side: A toothed belt connecting a joint and an actuator.","title":"Drive Parts"},{"location":"4_drive_parts/#bearings","text":"The bearings ensure a smooth connection between the joints and the body plates, due to tiny steel balls inside, which allow the parts to roll around each other with reduced friction. The assembly kit contains 20 KFL08 bearings, with the inside diameter of 8mm and two mounting holes. The bearings should be connected in pairs on each side of the wooden plates, as well as on the 3D-printed feet frames. It\u2019s important to place spring washers between the wood and the steel components, in order to protect the surface from damage, distribute the pressure, and prevent the bolts and nuts from moving or corroding. Bearings mounted on the wooden parts, marked with the red circles.","title":"Bearings"},{"location":"4_drive_parts/#toothed-belts","text":"Toothed belts are flexible bands with teeth carved onto their inner surface, designed to run over matching toothed pulleys. These belts ensure an indirect transmission between the joints and the motors, thereby making the connection between them more elastic and protecting the motors from the direct damage of heavy loads. However, this mechanism has a few disadvantages, such as lack of precision due to the mechanical freedom at the connecting points between the joints and the motors; as well as power loss, due to the motion devices between the motor and the joint which need to be moved. The indirect drive mechanism is rarely used in humanoid robotics and therefore represents an interesting research direction, as its elasticity allows more naturally looking movements of the robot. The 3D-printed pulleys of the motors and the joints are connected pairwise via 10 GT3 6mm wide toothed belts, eight of which have the pitch length of 303mm and the other two - 174mm. The position of the timing belts is very important because they define the movement ratio of the servos. Therefore, Matthias Kubisch recorded a helpful video where the installation of the toothed belts is demonstrated:","title":"Toothed Belts"},{"location":"5_printed_3d/","text":"3D-printed Parts In this section, we briefly introduce the 3D-printing technique of manufacturing objects and describe the 3D-printed components, namely: pulleys, joints, feet, motor covers and shells. 3D-printing is a low-cost manufacturing process of objects, by applying thin layers of a material, also called filament, onto one another. All open hardware robots come with CAD files containing the 3D models of different components, which can be either 3D-printed or reproduced through other manufacturing techniques. The 3D-printed parts for Gretchen were manufactured in an Ultimaker printer by using ABS plastic and tough PLA filament. The overview of the major 3D-printed components (from left to right): hip joint, ankle joint and foot, motor cover, knee joint, and pulley. Pulleys The joints of the robot have pulleys on the outer sides, which are coupled with the servo pulleys with toothed belts. Pulleys are wheels, designed to support the movement and change the direction of the belts along their circumference. The assembly kit contains pulleys that either differ in size or in the shape of the hole in the center. The D-spline motor pulleys from the assembly documentation, 10 in total, refer to the ones which have to be installed on the servo shaft instead of the horns (they are a default part of the servo set). The remaining four pulleys are used for the gimbal joint, which will be discussed in the following section. The terms 42T and 33T following the name of the pulleys, represent the number of teeth, carved into the surface of the pulleys. Top left: The hip joint. Bottom left: The knee joint. Right picture: Wooden body parts after connecting the wooden plates with the joints. Joints Each knee and hip joint consists of two 3D-printed parts, namely the inner and the outer one, which are shown in Figure 3.4. The knee components are symmetrical, the only difference being the integrated pulley on the outer side of the knee. Both parts should be connected through the shank bearing. It\u2019s important to use a moderate amount of power when screwing the nuts, in order to prevent the screw from damaging the plastic. The knee of the robot has only one degree of freedom - the pitch. The hip mechanism consists of a flat pulley on the outer side and an X/Y integrated pulley on the inner side. Before mounting the hips, one should check whether the hex nuts fit inside the pulleys. Depending on the tolerance of the 3D printer, the pocket of the pulley might be a bit loose, which can be solved by using superglue for fixing the nut. In case the pocket is a bit tight, one should use a clamp for adding a little force when inserting the nut inside it. Once the flat hex nut pulleys are done, the bolt must be inserted from the nut side first, in order to ensure continuous threading between the nut and the plastic surface. Before inserting the bolt through the other side, the remaining plastic or sharp edges should be removed, for instance, by using a paper cutter. A 15mm deep hole should be made in the pulley on the inner side of the hip, prior to connecting both pulleys through the hip bearings. This step should not be skipped, as, without it, the bolt would get stuck halfway through the assembly process of the hip joint. When connecting the hip components, a normal washer must be used at the outer side and the spring washer at the inner side. The ankle joint incorporates three 3D-printed components, namely, a 33 teeth pulley, a 42 teeth pulley, and a cardan gimbal frame. Both pulleys should be attached to the cardan joint, as shown in the picture below. The small pulley ensures the roll movement of the joint and the bigger one - the pitch movement. The first picture illustrates the ankle joint. In the left picture: the foot with the gimbal joint attached. Feet The feet of the robot are two perfectly identical 3D-printed parts. Before mounting the ankle joint on the foot frame, the toothed belt with the pitch length of 174mm should be inserted around the ankle. Note that in the right picture above, the toothed belt is missing, meaning that we had to unmount the ankle joint, put the belt around it and mount it again. Gretchen\u2019s feet are different from the majority of the other humanoid robots, as they carry one servo motor each. These servos enable the roll movement of each foot, however, they add extra weight to the feet and may, therefore, make walking more challenging and less energy-efficient. Motor Covers Since the new boards occupy more space than the old ones, due to the additional electronic components, the old motor cover cannot be used for closing the motor box. The assembly kit contains ten 3D-printed motor covers, which should hold the custom boards and attach them to the motor housing. As shown on the top left part of figure below, the side opening, designed for the bus connectors, may be slightly shifted (in this example to the right). This shift can result from the error of the 3D-printer. Therefore, in order to insert the board inside the cover, the side opening should be enlarged. We used a drill to make these holes a few mm wider. Shells Our assembly kit didn\u2019t include the shells, however, they represent a useful hardware component and are therefore worth mentioning. The 3D-printed shells were designed for protecting the electronic components and the belt system from collisions and damage. In the right picture of the figure below the Gretchen robot is shown, with the shells protecting its thighs, shanks and feet. The shells are mounted on 3D-printed adapters, which are attached to the wooden parts, as shown in the lower-left picture of figure below. The adapters allow a quick assembly and removal of the shells. Although the limbs of the robot weren\u2019t designed with attachment points for the shells, they have holes for cable management zip-ties, which can also be used for attaching the shell adapters. The shells for the thighs and the shanks consist of multiple 3D-printed pieces, and therefore can be printed by using a conventional 3D-printer. Top left picture: The Sensorimotor board situated halfway inside the 3D-printed motor cover. The side hole is slightly shifted to the right and the board doesn\u2019t fit inside the motor cover. Bottom left picture: A permanently attached adapter to the wooden part enables a quick assembly and removal of the shells. Right picture: The shells are protecting the thighs, shanks and feet of the robot.","title":"3D-printed Parts"},{"location":"5_printed_3d/#3d-printed-parts","text":"In this section, we briefly introduce the 3D-printing technique of manufacturing objects and describe the 3D-printed components, namely: pulleys, joints, feet, motor covers and shells. 3D-printing is a low-cost manufacturing process of objects, by applying thin layers of a material, also called filament, onto one another. All open hardware robots come with CAD files containing the 3D models of different components, which can be either 3D-printed or reproduced through other manufacturing techniques. The 3D-printed parts for Gretchen were manufactured in an Ultimaker printer by using ABS plastic and tough PLA filament. The overview of the major 3D-printed components (from left to right): hip joint, ankle joint and foot, motor cover, knee joint, and pulley.","title":"3D-printed Parts"},{"location":"5_printed_3d/#pulleys","text":"The joints of the robot have pulleys on the outer sides, which are coupled with the servo pulleys with toothed belts. Pulleys are wheels, designed to support the movement and change the direction of the belts along their circumference. The assembly kit contains pulleys that either differ in size or in the shape of the hole in the center. The D-spline motor pulleys from the assembly documentation, 10 in total, refer to the ones which have to be installed on the servo shaft instead of the horns (they are a default part of the servo set). The remaining four pulleys are used for the gimbal joint, which will be discussed in the following section. The terms 42T and 33T following the name of the pulleys, represent the number of teeth, carved into the surface of the pulleys. Top left: The hip joint. Bottom left: The knee joint. Right picture: Wooden body parts after connecting the wooden plates with the joints.","title":"Pulleys"},{"location":"5_printed_3d/#joints","text":"Each knee and hip joint consists of two 3D-printed parts, namely the inner and the outer one, which are shown in Figure 3.4. The knee components are symmetrical, the only difference being the integrated pulley on the outer side of the knee. Both parts should be connected through the shank bearing. It\u2019s important to use a moderate amount of power when screwing the nuts, in order to prevent the screw from damaging the plastic. The knee of the robot has only one degree of freedom - the pitch. The hip mechanism consists of a flat pulley on the outer side and an X/Y integrated pulley on the inner side. Before mounting the hips, one should check whether the hex nuts fit inside the pulleys. Depending on the tolerance of the 3D printer, the pocket of the pulley might be a bit loose, which can be solved by using superglue for fixing the nut. In case the pocket is a bit tight, one should use a clamp for adding a little force when inserting the nut inside it. Once the flat hex nut pulleys are done, the bolt must be inserted from the nut side first, in order to ensure continuous threading between the nut and the plastic surface. Before inserting the bolt through the other side, the remaining plastic or sharp edges should be removed, for instance, by using a paper cutter. A 15mm deep hole should be made in the pulley on the inner side of the hip, prior to connecting both pulleys through the hip bearings. This step should not be skipped, as, without it, the bolt would get stuck halfway through the assembly process of the hip joint. When connecting the hip components, a normal washer must be used at the outer side and the spring washer at the inner side. The ankle joint incorporates three 3D-printed components, namely, a 33 teeth pulley, a 42 teeth pulley, and a cardan gimbal frame. Both pulleys should be attached to the cardan joint, as shown in the picture below. The small pulley ensures the roll movement of the joint and the bigger one - the pitch movement. The first picture illustrates the ankle joint. In the left picture: the foot with the gimbal joint attached.","title":"Joints"},{"location":"5_printed_3d/#feet","text":"The feet of the robot are two perfectly identical 3D-printed parts. Before mounting the ankle joint on the foot frame, the toothed belt with the pitch length of 174mm should be inserted around the ankle. Note that in the right picture above, the toothed belt is missing, meaning that we had to unmount the ankle joint, put the belt around it and mount it again. Gretchen\u2019s feet are different from the majority of the other humanoid robots, as they carry one servo motor each. These servos enable the roll movement of each foot, however, they add extra weight to the feet and may, therefore, make walking more challenging and less energy-efficient.","title":"Feet"},{"location":"5_printed_3d/#motor-covers","text":"Since the new boards occupy more space than the old ones, due to the additional electronic components, the old motor cover cannot be used for closing the motor box. The assembly kit contains ten 3D-printed motor covers, which should hold the custom boards and attach them to the motor housing. As shown on the top left part of figure below, the side opening, designed for the bus connectors, may be slightly shifted (in this example to the right). This shift can result from the error of the 3D-printer. Therefore, in order to insert the board inside the cover, the side opening should be enlarged. We used a drill to make these holes a few mm wider.","title":"Motor Covers"},{"location":"5_printed_3d/#shells","text":"Our assembly kit didn\u2019t include the shells, however, they represent a useful hardware component and are therefore worth mentioning. The 3D-printed shells were designed for protecting the electronic components and the belt system from collisions and damage. In the right picture of the figure below the Gretchen robot is shown, with the shells protecting its thighs, shanks and feet. The shells are mounted on 3D-printed adapters, which are attached to the wooden parts, as shown in the lower-left picture of figure below. The adapters allow a quick assembly and removal of the shells. Although the limbs of the robot weren\u2019t designed with attachment points for the shells, they have holes for cable management zip-ties, which can also be used for attaching the shell adapters. The shells for the thighs and the shanks consist of multiple 3D-printed pieces, and therefore can be printed by using a conventional 3D-printer. Top left picture: The Sensorimotor board situated halfway inside the 3D-printed motor cover. The side hole is slightly shifted to the right and the board doesn\u2019t fit inside the motor cover. Bottom left picture: A permanently attached adapter to the wooden part enables a quick assembly and removal of the shells. Right picture: The shells are protecting the thighs, shanks and feet of the robot.","title":"Shells"},{"location":"6_servo_el_comp/","text":"Servos and electronic components The Gretchen robot is powered by 10 low-cost Hitec HS-805MG Mega servo motors , the distinguishing features of which are the custom Sensorimotor boards . These boards were designed by the creators of Gretchen, aiming to add more features, namely, more torque, sensory data, bus communication and customizable firmware to simple and low-cost servo motors, thereby drastically lowering the overall price of the robot. The servos are placed either above or below the robot\u2019s joints and are connected to them with toothed belts. The actuators are communicating with each other via the RS485 serial bus and with the computer - via a USB-to-Serial adapter . The available C++ libraries can be compiled on a Linux machine and the robot can be further developed through a Python API. The motion of the robot can be programmed using both position and torque control . The Libsensorimotor library offers an implementation of a PID controller, which is a position control mechanism. Servo For powering Gretchen the HS-805MG Mega Giant Scale, Metal Gear analog Servo is used. It belongs to the largest category of Hitec servos, with a heavy-duty metal gear train, a strong 10mm, 15 tooth output shaft which generates 2,4Nm of torque and a 3 pole brushed motor. This servo cannot be used for powering a robot just as it is, because of a few disadvantages. First, it cannot be easily connected to other servos in order to create a communication bus. Second, its on-board Hitec RCD ht7004 microcontroller is custom made and cannot be easily programmed, because there\u2019s no datasheet available online. These challenges can be undoubtedly solved with another servo motor, with publicly available microcontroller information, a more complex integrated circuit and bus connectors, but for a much higher price. The creators of Gretchen overcame these challenges by designing a custom board with an easily programmable on-board microcontroller, bus connectors and many more useful features that are displayed in the table below and will be discussed in the next subsection. Sensorimotor Boards As mentioned in the previous paragraph, the analog servo from the assembly kit has a few disadvantages and the custom boards and the electronic components from the assembly kit are a low-cost solution for overcoming them. The Sensorimotor boards have an ATmega328P 16MHz microcontroller , an ISP connector for programming it, two RS485 Bus connectors , an I2C bus connector , and a temperature sensor . The integrated circuit of the new board can handle a voltage up to 12V , which is twice as much as on the old board, thereby doubling the torque of the motor to 5Nm . This board can be used with other servos of similar size and features, with the maximum voltage limit of 12V. Before inserting the new board inside the servo, the old one has to be carefully removed, by desoldering the ground and the motor pins with a soldering iron and a desoldering pump. We used a 50W soldering station which can heat up to 450\u00b0C. We used a 1mm thick lead-free soldering wire with 99,3% tin and 0,7% copper. The grounding pin is sinking much heat and even after setting the maximum temperature, it was still very hard to desolder it, so we lifted most of the boards together with the ground pin and the glue with which it was fixed to the motor. In this case, the process of soldering a cable to the motor was more challenging, than when the grounding pin remained on the motor. We\u2019ll elaborate on solving this problem in the Cables and Wires Section. After removing the old board, the following components have to be soldered to the new one: a temperature sensor and a capacitor on the backside and an I2C connector , an ISP 6-pin header , and two rectangular 4-pin motorcord sockets on the front side of the board. The new board and the mentioned electronic components can be seen in the left picture below. Temerature Sensor The temperature sensor is placed on the backside of the board behind the microprocessor, in order to measure its temperature and eventually, prevent it from overheating. The KTY 81-110 silicon temperature sensor has a positive temperature coefficient (PTC), meaning that its electrical resistance increases with the temperature. This sensor is very stable and can measure the temperature in the range between -55\u00b0C and +150\u00b0C with a negligible drift over 50 years.The KTY 81-110 temperature sensor has 2 pins: GND (Ground) and ADC (Analog to Digital Converter). The ADC pin transforms the analog voltage input into the digital one, where a voltage change of 7.59 mV corresponds to a change of 1\u00b0C. The position of the temperature sensor is very important , because when closing the motor box, it will be tightly packed between the motor\u2019s \u2019hill\u2019 and one of the motor pins. The left picture below illustrates the damaged insulation of the motor wire positioned under the temperature sensor, which resulted after closing the servo cover. Damaged motor wire after closing the servo cover. This damage can potentially generate a short circuit and break the motor. In order to prevent this from happening, the feet of the temperature sensor should be bent 3 times by 90 degrees in a staircase shape, as shown in the second picture below. The body of the sensor should be placed below the H-bridge with the flat side faced to the board surface. The left picture below is an example of an incorrect positioning of the temperature sensor, since it exceeds the purple line. ISP header The 6-pin ISP header is used for flashing the firmware on the microcontroller, this process being called In-System-Programming (ISP) . The 6 pins of the ISP header correspond to the following lines: Master In \u2013 Slave Out (MISO), Serial Clock (SCK), Reset, Power, Master Out \u2013 Slave In (MOSI) and Ground. While soldering the ISP header, the pins shouldn\u2019t be heated for too long, as they heat up very fast and can change their position. We fixed the ISP header with tape, as shown in the left picture below. The tape stabilized the pins and prevented them from changing their position during the soldering process. Electrolytic capacitor The 220\u03bcF electrolytic capacitor is a polarized component that stores electricity and then discharges it into the circuit in case of an electricity drop. It has two pins of different lengths: the anode (the longer one) which receives voltage and the cathode (the shorter one) which sinks it to the ground. When soldering the capacitor, the cathode (ground lead) will sink a lot of heat, because it is directly connected to a large ground plane of the Sensorimotor board. We solved this issue by applying soldering fat around this pin, setting the maximum temperature on the soldering station and heating the area around the pin for a longer time. Due to the longer heating process, the ground pin of the capacitor has more flux than the other pin, as shown in the right picture above. RS485 bus sockets The rectangular 4-pin RS485 bus sockets are used for connecting the servos in a chain with the serial cables. Before soldering the bus sockets, it is important to push them tightly into the board surface, in order to ensure a stable connection after putting cables in and out multiple times. Each RS485 socket consists of 4 pins: GND, VCC, A and B. We elaborate on the functionality and its features in the Software Section about the RS-485 Bus. I2C connector The I2C connector can be used for connecting external sensors to the robot, such as the MPU6050 accelerometer and gyroscope sensor. The I2C (pronounced I-squared-C) serial protocol allows low-speed devices like microcontrollers and similar embedded systems to communicate with each other via a two-wire interface: SCL (clock line) and SDA (data line) [56]. It allows both multiple masters and slaves, and in our case, the AVR microcontroller acts as the master, meaning that it generates the clock and initiates the communication with the slave (e.g. MPU6050), which receives the clock and sends a response back. The master supplies the slave with voltage through the 3V3 pin and sinks it with the GND pin to the ground plane.","title":"Servos and electronic components"},{"location":"6_servo_el_comp/#servos-and-electronic-components","text":"The Gretchen robot is powered by 10 low-cost Hitec HS-805MG Mega servo motors , the distinguishing features of which are the custom Sensorimotor boards . These boards were designed by the creators of Gretchen, aiming to add more features, namely, more torque, sensory data, bus communication and customizable firmware to simple and low-cost servo motors, thereby drastically lowering the overall price of the robot. The servos are placed either above or below the robot\u2019s joints and are connected to them with toothed belts. The actuators are communicating with each other via the RS485 serial bus and with the computer - via a USB-to-Serial adapter . The available C++ libraries can be compiled on a Linux machine and the robot can be further developed through a Python API. The motion of the robot can be programmed using both position and torque control . The Libsensorimotor library offers an implementation of a PID controller, which is a position control mechanism.","title":"Servos and electronic components"},{"location":"6_servo_el_comp/#servo","text":"For powering Gretchen the HS-805MG Mega Giant Scale, Metal Gear analog Servo is used. It belongs to the largest category of Hitec servos, with a heavy-duty metal gear train, a strong 10mm, 15 tooth output shaft which generates 2,4Nm of torque and a 3 pole brushed motor. This servo cannot be used for powering a robot just as it is, because of a few disadvantages. First, it cannot be easily connected to other servos in order to create a communication bus. Second, its on-board Hitec RCD ht7004 microcontroller is custom made and cannot be easily programmed, because there\u2019s no datasheet available online. These challenges can be undoubtedly solved with another servo motor, with publicly available microcontroller information, a more complex integrated circuit and bus connectors, but for a much higher price. The creators of Gretchen overcame these challenges by designing a custom board with an easily programmable on-board microcontroller, bus connectors and many more useful features that are displayed in the table below and will be discussed in the next subsection.","title":"Servo"},{"location":"6_servo_el_comp/#sensorimotor-boards","text":"As mentioned in the previous paragraph, the analog servo from the assembly kit has a few disadvantages and the custom boards and the electronic components from the assembly kit are a low-cost solution for overcoming them. The Sensorimotor boards have an ATmega328P 16MHz microcontroller , an ISP connector for programming it, two RS485 Bus connectors , an I2C bus connector , and a temperature sensor . The integrated circuit of the new board can handle a voltage up to 12V , which is twice as much as on the old board, thereby doubling the torque of the motor to 5Nm . This board can be used with other servos of similar size and features, with the maximum voltage limit of 12V. Before inserting the new board inside the servo, the old one has to be carefully removed, by desoldering the ground and the motor pins with a soldering iron and a desoldering pump. We used a 50W soldering station which can heat up to 450\u00b0C. We used a 1mm thick lead-free soldering wire with 99,3% tin and 0,7% copper. The grounding pin is sinking much heat and even after setting the maximum temperature, it was still very hard to desolder it, so we lifted most of the boards together with the ground pin and the glue with which it was fixed to the motor. In this case, the process of soldering a cable to the motor was more challenging, than when the grounding pin remained on the motor. We\u2019ll elaborate on solving this problem in the Cables and Wires Section. After removing the old board, the following components have to be soldered to the new one: a temperature sensor and a capacitor on the backside and an I2C connector , an ISP 6-pin header , and two rectangular 4-pin motorcord sockets on the front side of the board. The new board and the mentioned electronic components can be seen in the left picture below.","title":"Sensorimotor Boards"},{"location":"6_servo_el_comp/#temerature-sensor","text":"The temperature sensor is placed on the backside of the board behind the microprocessor, in order to measure its temperature and eventually, prevent it from overheating. The KTY 81-110 silicon temperature sensor has a positive temperature coefficient (PTC), meaning that its electrical resistance increases with the temperature. This sensor is very stable and can measure the temperature in the range between -55\u00b0C and +150\u00b0C with a negligible drift over 50 years.The KTY 81-110 temperature sensor has 2 pins: GND (Ground) and ADC (Analog to Digital Converter). The ADC pin transforms the analog voltage input into the digital one, where a voltage change of 7.59 mV corresponds to a change of 1\u00b0C. The position of the temperature sensor is very important , because when closing the motor box, it will be tightly packed between the motor\u2019s \u2019hill\u2019 and one of the motor pins. The left picture below illustrates the damaged insulation of the motor wire positioned under the temperature sensor, which resulted after closing the servo cover. Damaged motor wire after closing the servo cover. This damage can potentially generate a short circuit and break the motor. In order to prevent this from happening, the feet of the temperature sensor should be bent 3 times by 90 degrees in a staircase shape, as shown in the second picture below. The body of the sensor should be placed below the H-bridge with the flat side faced to the board surface. The left picture below is an example of an incorrect positioning of the temperature sensor, since it exceeds the purple line.","title":"Temerature Sensor"},{"location":"6_servo_el_comp/#isp-header","text":"The 6-pin ISP header is used for flashing the firmware on the microcontroller, this process being called In-System-Programming (ISP) . The 6 pins of the ISP header correspond to the following lines: Master In \u2013 Slave Out (MISO), Serial Clock (SCK), Reset, Power, Master Out \u2013 Slave In (MOSI) and Ground. While soldering the ISP header, the pins shouldn\u2019t be heated for too long, as they heat up very fast and can change their position. We fixed the ISP header with tape, as shown in the left picture below. The tape stabilized the pins and prevented them from changing their position during the soldering process.","title":"ISP header"},{"location":"6_servo_el_comp/#electrolytic-capacitor","text":"The 220\u03bcF electrolytic capacitor is a polarized component that stores electricity and then discharges it into the circuit in case of an electricity drop. It has two pins of different lengths: the anode (the longer one) which receives voltage and the cathode (the shorter one) which sinks it to the ground. When soldering the capacitor, the cathode (ground lead) will sink a lot of heat, because it is directly connected to a large ground plane of the Sensorimotor board. We solved this issue by applying soldering fat around this pin, setting the maximum temperature on the soldering station and heating the area around the pin for a longer time. Due to the longer heating process, the ground pin of the capacitor has more flux than the other pin, as shown in the right picture above.","title":"Electrolytic capacitor"},{"location":"6_servo_el_comp/#rs485-bus-sockets","text":"The rectangular 4-pin RS485 bus sockets are used for connecting the servos in a chain with the serial cables. Before soldering the bus sockets, it is important to push them tightly into the board surface, in order to ensure a stable connection after putting cables in and out multiple times. Each RS485 socket consists of 4 pins: GND, VCC, A and B. We elaborate on the functionality and its features in the Software Section about the RS-485 Bus.","title":"RS485 bus sockets"},{"location":"6_servo_el_comp/#i2c-connector","text":"The I2C connector can be used for connecting external sensors to the robot, such as the MPU6050 accelerometer and gyroscope sensor. The I2C (pronounced I-squared-C) serial protocol allows low-speed devices like microcontrollers and similar embedded systems to communicate with each other via a two-wire interface: SCL (clock line) and SDA (data line) [56]. It allows both multiple masters and slaves, and in our case, the AVR microcontroller acts as the master, meaning that it generates the clock and initiates the communication with the slave (e.g. MPU6050), which receives the clock and sends a response back. The master supplies the slave with voltage through the 3V3 pin and sinks it with the GND pin to the ground plane.","title":"I2C connector"},{"location":"7_cables_wires/","text":"Cables and Wires Self-made cables are another important component that keeps the overall costs of the robot lower. In this section, we first elaborate on the wires connecting the servo motor to the Sensorimotor board ( motor and potentiometer wires ) and then the cables connecting the servos between each other ( RS485 bus cables ). Motor and Potentiometer Wires Each servo should have three 5cm wires connecting the ground and the motor pins to the board. A stripping tool is required for removing around 4mm of insulation from both ends of all wires. The wires\u2019 ends should be twisted and pre-soldered , in order to hold the wires together and ensure a good electrical connection. If the ground pin was removed when desoldering the old servo board, then the remaining glue on the motor should be first removed. We used sandpaper to make the motor\u2019s surface smooth. Then we applied zinc chloride on the area where the ground pin would be soldered. Zinc chloride is a corrosive substance used for the pre-fluxing of metals prior to soldering. We soldered the ground cable to the motor by using a gas torch , which can heat its tip up to 550\u000eC. After soldering the cables to the motor, we cut diagonally 5mm long pieces of sleeving , in order to cover the ground and the motor pins . We used the open flame option of the gas torch for shrinking the sleeving tubes and isolating the motor pins. This is an important step because the cables will be packed tightly near each other after closing the motor box and open contacts may therefore generate a short circuit . The copper potentiometer cables are not as heat resistant as the silicone ones , because copper and silicon wire insulation break down if the temperature exceeds 100\u00b0C and 250\u00b0C respectively. Therefore, while pre-soldering them, the insulation might start melting . In order to avoid this, we dipped the twisted wires\u2019 ends into soldering fat , therefore significantly speeding up the pre-soldering process. RS485 Bus Cables The connection between the servos is ensured by the RS485 bus , which consists of cables with 4 wires each: ground, power, data lines A and B. The distance between the motors is different, therefore cables of the following lengths are required: 42cm (4 cables), 38cm (2 cables) and 16cm (3 cables). Custom made cables have two major advantages: low manufacturing costs and the exact necessary length . Nevertheless, self-manufacturing may be time-consuming if a crimping tool is not available and if not handled with care, the connectivity of the cable might be reduced due to insulation damage. Using cables of different colors is not compulsory, but it may ease the manufacturing process as well as denote a personalized style. Therefore the black silicone cables are used for denoting the ground and the data lines and the red cable is used for the voltage carrying line. The cables should be twisted pairwise 4 to 6 times, in order to reduce the electromagnetic noise . Connecting the actuators with the RS485 cables represents the last step of the hardware assembly. Finally, we tied the cables close to the wooden parts using zip-ties.","title":"Cables and Wires"},{"location":"7_cables_wires/#cables-and-wires","text":"Self-made cables are another important component that keeps the overall costs of the robot lower. In this section, we first elaborate on the wires connecting the servo motor to the Sensorimotor board ( motor and potentiometer wires ) and then the cables connecting the servos between each other ( RS485 bus cables ).","title":"Cables and Wires"},{"location":"7_cables_wires/#motor-and-potentiometer-wires","text":"Each servo should have three 5cm wires connecting the ground and the motor pins to the board. A stripping tool is required for removing around 4mm of insulation from both ends of all wires. The wires\u2019 ends should be twisted and pre-soldered , in order to hold the wires together and ensure a good electrical connection. If the ground pin was removed when desoldering the old servo board, then the remaining glue on the motor should be first removed. We used sandpaper to make the motor\u2019s surface smooth. Then we applied zinc chloride on the area where the ground pin would be soldered. Zinc chloride is a corrosive substance used for the pre-fluxing of metals prior to soldering. We soldered the ground cable to the motor by using a gas torch , which can heat its tip up to 550\u000eC. After soldering the cables to the motor, we cut diagonally 5mm long pieces of sleeving , in order to cover the ground and the motor pins . We used the open flame option of the gas torch for shrinking the sleeving tubes and isolating the motor pins. This is an important step because the cables will be packed tightly near each other after closing the motor box and open contacts may therefore generate a short circuit . The copper potentiometer cables are not as heat resistant as the silicone ones , because copper and silicon wire insulation break down if the temperature exceeds 100\u00b0C and 250\u00b0C respectively. Therefore, while pre-soldering them, the insulation might start melting . In order to avoid this, we dipped the twisted wires\u2019 ends into soldering fat , therefore significantly speeding up the pre-soldering process.","title":"Motor and Potentiometer Wires"},{"location":"7_cables_wires/#rs485-bus-cables","text":"The connection between the servos is ensured by the RS485 bus , which consists of cables with 4 wires each: ground, power, data lines A and B. The distance between the motors is different, therefore cables of the following lengths are required: 42cm (4 cables), 38cm (2 cables) and 16cm (3 cables). Custom made cables have two major advantages: low manufacturing costs and the exact necessary length . Nevertheless, self-manufacturing may be time-consuming if a crimping tool is not available and if not handled with care, the connectivity of the cable might be reduced due to insulation damage. Using cables of different colors is not compulsory, but it may ease the manufacturing process as well as denote a personalized style. Therefore the black silicone cables are used for denoting the ground and the data lines and the red cable is used for the voltage carrying line. The cables should be twisted pairwise 4 to 6 times, in order to reduce the electromagnetic noise . Connecting the actuators with the RS485 cables represents the last step of the hardware assembly. Finally, we tied the cables close to the wooden parts using zip-ties.","title":"RS485 Bus Cables"},{"location":"8_power_supply/","text":"Power Supply After finishing soldering the boards and connecting them with the motor and potentiometer wires to the servo motors, it can be beneficial to check if nothing is broken at this point. We checked the boards for short circuits with a multimeter before closing the lid and plugging a power supply into the servo for the first time. As mentioned in the previous paragraphs, the cables are packed very tightly in the motor\u2019s housing and there\u2019s a probability that the wire\u2019s insulation gets damaged when pressing the board inside the motor, which might result in a short circuit and a broken motor. Therefore, we checked the boards for short circuits both before and after closing the servo lid , in order to make debugging easier in case a problem would have been detected. When connecting to the RS485 bus, it is necessary to use an external DC source of power , which can produce a constant output voltage. A single servo can draw up to 6000mA and the input voltage range is from 5V up to 12.6V . The HS-805MG servos can properly function with an input voltage of 6V, but due to the new electronic components, it can be powered with doubled power and therefore deliver twice as much torque. Therefore, for the best performance of the servo motors, it is recommended to either use a 12V power adapter plugged to a power socket or a lithium polymer (LiPo) battery with 3 cells . Each cell of a LiPo battery has a nominal voltage of 3.7V so a battery with 3 cells will deliver around 11,1V. We manufactured a Y-shaped adapter for connecting the serial bus to a computer via a USB-to-Serial device and a power supply, as shown in the figure below.","title":"Power Supply"},{"location":"8_power_supply/#power-supply","text":"After finishing soldering the boards and connecting them with the motor and potentiometer wires to the servo motors, it can be beneficial to check if nothing is broken at this point. We checked the boards for short circuits with a multimeter before closing the lid and plugging a power supply into the servo for the first time. As mentioned in the previous paragraphs, the cables are packed very tightly in the motor\u2019s housing and there\u2019s a probability that the wire\u2019s insulation gets damaged when pressing the board inside the motor, which might result in a short circuit and a broken motor. Therefore, we checked the boards for short circuits both before and after closing the servo lid , in order to make debugging easier in case a problem would have been detected. When connecting to the RS485 bus, it is necessary to use an external DC source of power , which can produce a constant output voltage. A single servo can draw up to 6000mA and the input voltage range is from 5V up to 12.6V . The HS-805MG servos can properly function with an input voltage of 6V, but due to the new electronic components, it can be powered with doubled power and therefore deliver twice as much torque. Therefore, for the best performance of the servo motors, it is recommended to either use a 12V power adapter plugged to a power socket or a lithium polymer (LiPo) battery with 3 cells . Each cell of a LiPo battery has a nominal voltage of 3.7V so a battery with 3 cells will deliver around 11,1V. We manufactured a Y-shaped adapter for connecting the serial bus to a computer via a USB-to-Serial device and a power supply, as shown in the figure below.","title":"Power Supply"},{"location":"9_software_intro/","text":"Gretchen - Software The Gretchen robot doesn\u2019t have an embedded computer, and its software can be therefore divided into two major software modules : one module - runs on the embedded microcontroller on the board of each servo motor ; and the second module - runs on an external computer and communicates with the robot via a cable . A high-level structure of these modules is illustrated in the figure below and in the next few paragraphs we give a general overview of each of them. Overview over the most important software components running on the Sensorimotor boards and the external computer, and data flow of Gretchen. Red arrows illustrate the RS-485 bus connecting the motor boards. In the middle of the figure above, the Gretchen robot is illustrated with 10 servo motors, which communicate with each other through a serial bus - marked with the red arrows. Each servo motor has an inbuilt Sensorimotor board , which has an embedded microcontroller , which is illustrated on the left side of the figure. The main software module that runs on the embedded microcontroller is called firmware . The source code for the firmware can be found in the Sensorimotor repository , together with several test programs, tools, documentation and board circuits. The firmware contains the necessary programs that manage the communication between the actuators and the computer via the serial bus, control the servo itself and process the acquired motor and sensor data. The firmware can be edited or changed entirely , due to the open-source nature of the robot. The desired firmware is uploaded on the microcontroller of the board via the ISP interface and the motors are communicating with the computer via a USB-to-Serial adapter. Both of these communication interfaces will be discussed in the following section. The module illustrated on the right side of figure above represents the high-level architecture of the software libraries, which run on an external computer and are used to control the motions of the robot. These libraries are available in the Libsensorimotor repository and can be divided into two main parts, written in different programming languages, namely: C++ and Python. The C++ libraries manage the low-level communication of the computer with the serial bus and control the actuators using different control mechanisms. The Python API provides a high-level and simplified interface to control the motion of the robot, without requiring extensive knowledge about the complex communication and control mechanisms of the C++ libraries. The experimental assembly and software setup processes have shown the importance of being familiar with several basic notions from computer science and electrical engineering, which are necessary for understanding the structure and the underlying concepts of the control software. Therefore, we\u2019ve included the definitions and explanations of relevant notions at the beginning of the following sections, before elaborating on their functionality and purpose in the context of the Gretchen robot. In the Firmware and Sensorimotor Boards Section, the connection between the hardware and the software is closely examined. We scrutinize the embedded microcontroller , namely its features, firmware and communication capabilities . Furthermore, several motor control approaches are discussed and compared in the Motor Control Section. Finally, in the Libsensorimotor - Python API Section , the implementation of one of the control approaches, as well as a few motion experiments are described.","title":"Gretchen - Software"},{"location":"9_software_intro/#gretchen-software","text":"The Gretchen robot doesn\u2019t have an embedded computer, and its software can be therefore divided into two major software modules : one module - runs on the embedded microcontroller on the board of each servo motor ; and the second module - runs on an external computer and communicates with the robot via a cable . A high-level structure of these modules is illustrated in the figure below and in the next few paragraphs we give a general overview of each of them. Overview over the most important software components running on the Sensorimotor boards and the external computer, and data flow of Gretchen. Red arrows illustrate the RS-485 bus connecting the motor boards. In the middle of the figure above, the Gretchen robot is illustrated with 10 servo motors, which communicate with each other through a serial bus - marked with the red arrows. Each servo motor has an inbuilt Sensorimotor board , which has an embedded microcontroller , which is illustrated on the left side of the figure. The main software module that runs on the embedded microcontroller is called firmware . The source code for the firmware can be found in the Sensorimotor repository , together with several test programs, tools, documentation and board circuits. The firmware contains the necessary programs that manage the communication between the actuators and the computer via the serial bus, control the servo itself and process the acquired motor and sensor data. The firmware can be edited or changed entirely , due to the open-source nature of the robot. The desired firmware is uploaded on the microcontroller of the board via the ISP interface and the motors are communicating with the computer via a USB-to-Serial adapter. Both of these communication interfaces will be discussed in the following section. The module illustrated on the right side of figure above represents the high-level architecture of the software libraries, which run on an external computer and are used to control the motions of the robot. These libraries are available in the Libsensorimotor repository and can be divided into two main parts, written in different programming languages, namely: C++ and Python. The C++ libraries manage the low-level communication of the computer with the serial bus and control the actuators using different control mechanisms. The Python API provides a high-level and simplified interface to control the motion of the robot, without requiring extensive knowledge about the complex communication and control mechanisms of the C++ libraries. The experimental assembly and software setup processes have shown the importance of being familiar with several basic notions from computer science and electrical engineering, which are necessary for understanding the structure and the underlying concepts of the control software. Therefore, we\u2019ve included the definitions and explanations of relevant notions at the beginning of the following sections, before elaborating on their functionality and purpose in the context of the Gretchen robot. In the Firmware and Sensorimotor Boards Section, the connection between the hardware and the software is closely examined. We scrutinize the embedded microcontroller , namely its features, firmware and communication capabilities . Furthermore, several motor control approaches are discussed and compared in the Motor Control Section. Finally, in the Libsensorimotor - Python API Section , the implementation of one of the control approaches, as well as a few motion experiments are described.","title":"Gretchen - Software"}]}